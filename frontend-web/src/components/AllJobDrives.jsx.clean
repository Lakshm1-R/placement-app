import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../contexts/AuthContext";
import axios from "axios";
import toast from "react-hot-toast";
import PRJobCard from "./PRJobCard";
import RoundManagementModal from "./RoundManagementModal";
import {
  useJobDriveUpdates,
  useDeletionRequestUpdates,
  useApplicationUpdates,
  useSocketConnection,
  useModalUpdates,
  useRoundUpdates,
} from "../hooks/useSocket";

const normalizeDepartment = (dept) => {
  if (!dept) return null;
  return dept.toLowerCase().trim();
};

const AllJobDrives = () => {
  const { user } = useAuth();
  const navigate = useNavigate();
  const [drives, setDrives] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState("all");
  const [showModal, setShowModal] = useState(false);
  const [selectedDrive, setSelectedDrive] = useState(null);
  const [showPlacedStudentsViewModal, setShowPlacedStudentsViewModal] =
    useState(false);
  const [selectedDriveForView, setSelectedDriveForView] = useState(null);
  const [showRoundModal, setShowRoundModal] = useState(false);
  const [selectedJobForRounds, setSelectedJobForRounds] = useState(null);
  const [selectedRoundIndex, setSelectedRoundIndex] = useState(null);
  const [showRoundStudentsModal, setShowRoundStudentsModal] = useState(false);
  const [selectedRound, setSelectedRound] = useState(null);
  const [selectedJobForRoundView, setSelectedJobForRoundView] = useState(null);
  const [showManageRoundsModal, setShowManageRoundsModal] = useState(false);
  const [selectedDriveForRounds, setSelectedDriveForRounds] = useState(null);
  const [selectedRoundForManagement, setSelectedRoundForManagement] =
    useState(null);
  const [roundApplicants, setRoundApplicants] = useState([]);
  const [selectedStudentsForRound, setSelectedStudentsForRound] = useState([]);
  const [loadingApplicants, setLoadingApplicants] = useState(false);

  // Deletion confirmation modal states
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [deleteTarget, setDeleteTarget] = useState(null);
  const [deleteReason, setDeleteReason] = useState("");

  // Student deletion states
  const [showDeleteStudentModal, setShowDeleteStudentModal] = useState(false);
  const [deleteStudentIndex, setDeleteStudentIndex] = useState(null);

  // Helper function to count placed students (matches PO dashboard logic)
  const getPlacedStudentsCount = (drive) => {
    // Check if drive has ended first
    const driveEnded = isDriveEnded(drive);
    
    // Only count from selection rounds if drive has ended
    if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
      const lastRound = drive.selectionRounds[drive.selectionRounds.length - 1];
      const countFromRounds = lastRound.selectedStudents?.length || 0;
      if (countFromRounds > 0) {
        return countFromRounds;
      }
    }
    
    // Always allow manual placed students (regardless of drive end date)
    return drive.placedStudents?.length || 0;
  };

  // Socket connection and real-time updates
  useSocketConnection(user?.role);

  // Handle real-time job drive updates
  useJobDriveUpdates((data) => {
    const { action } = data;

    // Refetch all job drives to get the latest data
    if (
      action === "created" ||
      action === "updated" ||
      action === "deleted" ||
      action === "application_submitted"
    ) {
      fetchAllJobDrives();
    }
  });

  // Handle real-time deletion request updates
  useDeletionRequestUpdates((data) => {
    const { action } = data;

    // Refetch all job drives when deletion is approved
    if (action === "approved") {
      fetchAllJobDrives();
    }
  });

  // Handle real-time application updates
  useApplicationUpdates((data) => {
    // Refetch drives when application status changes
    fetchAllJobDrives();
  });

  // Handle real-time modal updates
  useModalUpdates(selectedDrive?._id, (updatedDrive, action) => {
    if (action === 'updated') {
      // Update the selected drive data in the modal
      setSelectedDrive(updatedDrive);
    }
  });

  // Handle real-time round updates
  useRoundUpdates((data) => {
    const { action, jobDrive } = data;
    
    // If modal is open for this drive, refresh the selected drive data
    if (selectedDrive && jobDrive && (jobDrive._id === selectedDrive._id || jobDrive.id === selectedDrive._id)) {
      setSelectedDrive(jobDrive);
    }
    
    // If round management modal is open, refresh that too
    if (selectedDriveForRounds && jobDrive && (jobDrive._id === selectedDriveForRounds._id || jobDrive.id === selectedDriveForRounds._id)) {
      setSelectedDriveForRounds(jobDrive);
    }
    
    // Refresh the drives list
    fetchAllJobDrives();
  });

  // Add these helper functions at the top of the component
  const isDriveCreator = (drive) => {
    const isCreator = drive.createdBy?._id === user?.id;
    console.log("=== CREATOR CHECK ===");
    console.log("Drive:", drive.companyName);
    console.log("Drive creator ID:", drive.createdBy?._id);
    console.log("Current user ID:", user?.id);
    console.log("Is creator:", isCreator);
    return isCreator;
  };

  const canManageDrive = (drive) => {
    // If no createdBy info, nobody can manage
    if (!drive.createdBy) {
      console.log("❌ No creator info - no management access");
      return false;
    }

    // Check if user created the drive
    const isCreator = isDriveCreator(drive);

    // For PRs - also check department access
    if (user?.role === "placement_representative" || user?.role === "pr") {
      const userDept = normalizeDepartment(user.profile?.department);
      const creatorDept = normalizeDepartment(
        drive.createdBy?.profile?.department
      );

      console.log("=== MANAGE ACCESS CHECK ===");
      console.log("Drive:", drive.companyName);
      console.log("User:", user.email);
      console.log("User Dept (normalized):", userDept);
      console.log("Creator:", drive.createdBy.email);
      console.log("Creator Dept (normalized):", creatorDept);
      console.log("Is creator:", isCreator);

      // Allow if same department OR if user created the drive
      if (isCreator || (userDept && creatorDept && userDept === creatorDept)) {
        console.log(
          "✅ Management access granted - same department or creator"
        );
        return true;
      } else {
        console.log("❌ Different department and not creator - access denied");
        return false;
      }
    }

    // For POs - they can manage everything
    if (user?.role === "po" || user?.role === "placement_officer") {
      return true;
    }

    return isCreator;
  };

  const isViewOnlyPR = (drive) => {
    return (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      !canManageDrive(drive)
    );
  };

  // Function to check if applications are still open (for application deadline)
  const isApplicationDeadlinePassed = (drive) => {
    // If there's a deadline, use that; otherwise use drive date
    const checkDate = drive.deadline || drive.date;
    if (!checkDate) return false;

    const deadlineDateTime = new Date(checkDate);

    // If drive has a specific time, use it; otherwise assume end of day
    if (drive.time && drive.deadline) {
      const [hours, minutes] = drive.time.split(":");
      deadlineDateTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
    } else {
      // If no time specified, consider applications open until end of deadline day
      deadlineDateTime.setHours(23, 59, 59, 999);
    }

    const currentDateTime = new Date();
    return currentDateTime > deadlineDateTime;
  };

  // Function to check if drive has ended (for filtering purposes)
  const isDriveEnded = (drive) => {
    if (!drive.date) return false;

    const driveDate = new Date(drive.date);
    const currentDate = new Date();

    // If drive has time, use it for comparison
    if (drive.time) {
      const [hours, minutes] = drive.time.split(":").map(Number);
      driveDate.setHours(hours, minutes, 0, 0);
      return currentDate > driveDate;
    } else {
      // If no time specified, consider drive ended at end of day
      driveDate.setHours(23, 59, 59, 999);
      return currentDate > driveDate;
    }
  };

  const handleViewPlacedStudents = async (drive) => {
    try {
      const driveEnded = isDriveEnded(drive);
      
      // Only try to get students from selection rounds if drive has ended
      if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
        const token = localStorage.getItem("token");
        const response = await fetch(
          `http://localhost:5000/api/job-drives/${drive._id}/last-round-students`,
          {
            method: "GET",
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        if (response.ok) {
          const data = await response.json();
          if (data.students && data.students.length > 0) {
            // Create a drive object with the selection round students for modal display
            const driveWithRoundStudents = {
              ...drive,
              placedStudents: data.students, // Use students from final round
            };
            setSelectedDriveForView(driveWithRoundStudents);
            setShowPlacedStudentsViewModal(true);
            return;
          }
        }
      }

      // Always allow viewing manual placed students (regardless of drive end date)
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
        return;
      }

      // If no placed students found from either source
      toast.error("No placed students found for this drive");
    } catch (error) {
      console.error("Error fetching placed students:", error);
      // Fallback to showing manual placed students if API call fails
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
      } else {
        toast.error("Failed to fetch placed students");
      }
    }
  };

  useEffect(() => {
    // Wait for auth context to load before checking user
    if (user === null) {
      // Still loading auth state, don't redirect yet
      return;
    }

    // Allow both placement_representative and placement_officer
    if (
      !user ||
      (user.role !== "placement_representative" &&
        user.role !== "placement_officer" &&
        user.role !== "po")
    ) {
      navigate("/login");
      return;
    }
    fetchAllJobDrives();
  }, [user, navigate]);

  const fetchAllJobDrives = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem("token");
      const response = await axios.get("http://localhost:5000/api/job-drives", {
        headers: { Authorization: `Bearer ${token}` },
      });

      console.log("=== API RESPONSE DEBUG ===");
      console.log("Full response:", response.data);
      console.log("Job drives:", response.data.jobDrives);

      // Debug each drive's creator info
      response.data.jobDrives.forEach((drive, index) => {
        console.log(`Drive ${index + 1} (${drive.companyName}):`, {
          createdBy: drive.createdBy,
          createdById: drive.createdBy?._id,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      setDrives(response.data.jobDrives || []);
    } catch (error) {
      console.error("Error fetching job drives:", error);
      toast.error("Failed to fetch job drives");
    } finally {
      setLoading(false);
    }
  };

  // Add this useEffect to debug the data
  useEffect(() => {
    if (drives.length > 0) {
      console.log("=== DRIVES DEBUG ===");
      drives.forEach((drive, index) => {
        console.log(`Drive ${index + 1}:`, {
          company: drive.companyName,
          createdBy: drive.createdBy,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      console.log("Current user:", {
        role: user?.role,
        department: user?.profile?.department,
        profile: user?.profile,
      });
    }
  }, [drives, user]);

  const handleDeleteDrive = async (driveId) => {
    // Get drive details for the confirmation
    const drive = drives.find((d) => d._id === driveId);
    const driveName = drive
      ? `${drive.companyName} - ${drive.role}`
      : "this job drive";

    // Set up deletion target and show modal
    setDeleteTarget({
      id: driveId,
      name: driveName,
      drive: drive,
    });
    setShowDeleteModal(true);
  };

  const confirmDeleteDrive = async () => {
    if (!deleteTarget) return;

    // For PRs, validate reason
    if (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      (!deleteReason || deleteReason.trim() === "")
    ) {
      toast.error("Reason is required for deletion request");
      return;
    }

    try {
      const token = localStorage.getItem("token");

      // Use the new deletion request API
      await axios.post(
        "http://localhost:5000/api/deletion-requests/request",
        {
          jobDriveId: deleteTarget.id,
          reason: deleteReason || "Administrative deletion",
        },
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );

      if (user?.role === "po" || user?.role === "placement_officer") {
        toast.success("Job drive deleted successfully");
        setDrives(drives.filter((drive) => drive._id !== deleteTarget.id));
      } else {
        toast.success(
          "Deletion request submitted successfully. Awaiting PO approval."
        );
        // Don't remove from list as it's pending approval
      }

      // Close modal and reset state
      setShowDeleteModal(false);
      setDeleteTarget(null);
      setDeleteReason("");
    } catch (error) {
      console.error("Delete error:", error);
      if (error.response?.data?.message) {
        toast.error(error.response.data.message);
      } else {
        toast.error("Failed to process deletion request");
      }
    }
  };

  const cancelDelete = () => {
    setShowDeleteModal(false);
    setDeleteTarget(null);
    setDeleteReason("");
  };

  const handleEditDrive = (driveId) => {
    navigate(`/pr/edit-job/${driveId}?returnTo=/all-job-drives`);
  };

  const handleViewDetails = (drive) => {
    console.log("=== DRIVE DETAILS DEBUG ===");
    console.log("Full drive object:", JSON.stringify(drive, null, 2));
    console.log("Eligibility object:", drive.eligibility);
    console.log("Min CGPA field:", drive.eligibility?.minCGPA);
    console.log("CGPA field:", drive.eligibility?.cgpa);
    console.log("Test Details:", drive.testDetails);
    console.log("Interview Process:", drive.interviewProcess);
    console.log("Bond:", drive.bond);

    setSelectedDrive(drive);
    setShowModal(true);
  };

  const closeModal = () => {
    setShowModal(false);
    setSelectedDrive(null);
  };

  const getFilteredDrives = () => {
    console.log("=== ALL JOB DRIVES FILTERING ===");
    console.log("Total drives:", drives.length);
    console.log("Current filter:", filter);
    console.log("User role:", user?.role);

    return drives.filter((drive) => {
      const driveEnded = isDriveEnded(drive);
      console.log(
        `Drive ${drive.companyName}: ended=${driveEnded}, date=${drive.date}, time=${drive.time}`
      );

      if (filter === "upcoming") {
        return !driveEnded; // Not ended yet
      } else if (filter === "past") {
        return driveEnded; // Drive has ended
      }
      return true; // 'all' filter
    });
  };

  const downloadCSV = () => {
    if (!selectedDriveForView?.placedStudents?.length) {
      toast.error("No data to download");
      return;
    }

    const headers = [
      "S.No",
      "Name",
      "Roll Number",
      "Department",
      "Email",
      "Mobile",
      "Added On",
    ];
    const csvContent = [
      headers.join(","),
      ...selectedDriveForView.placedStudents.map((student, index) =>
        [
          index + 1,
          `"${student.name}"`,
          `"${student.rollNumber}"`,
          `"${student.department || "N/A"}"`,
          `"${student.email}"`,
          `"${student.mobileNumber || "N/A"}"`,
          `"${
            student.addedAt
              ? new Date(student.addedAt).toLocaleDateString()
              : "N/A"
          }"`,
        ].join(",")
      ),
    ].join("\n");

    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute(
      "download",
      `${selectedDriveForView.companyName}_placed_students.csv`
    );
    link.style.visibility = "hidden";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const handleManageRounds = (drive, roundIndex) => {
    // For same department PRs - full management access
    setSelectedJobForRounds(drive);
    setSelectedRoundIndex(roundIndex);
    setShowRoundModal(true);
  };
import { useAuth } from "../contexts/AuthContext";
import axios from "axios";
import toast from "react-hot-toast";
import PRJobCard from "./PRJobCard";
import RoundManagementModal from "./RoundManagementModal";
import {
  useJobDriveUpdates,
  useDeletionRequestUpdates,
  useApplicationUpdates,
  useSocketConnection,
  useModalUpdates,
  useRoundUpdates,
} from "../hooks/useSocket";

const normalizeDepartment = (dept) => {
  if (!dept) return null;
  return dept.toLowerCase().trim();
};

const AllJobDrives = () => {
  const { user } = useAuth();
  const navigate = useNavigate();
  const [drives, setDrives] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState("all");
  const [showModal, setShowModal] = useState(false);
  const [selectedDrive, setSelectedDrive] = useState(null);
  const [showPlacedStudentsViewModal, setShowPlacedStudentsViewModal] =
    useState(false);
  const [selectedDriveForView, setSelectedDriveForView] = useState(null);
  const [showRoundModal, setShowRoundModal] = useState(false);
  const [selectedJobForRounds, setSelectedJobForRounds] = useState(null);
  const [selectedRoundIndex, setSelectedRoundIndex] = useState(null);
  const [showRoundStudentsModal, setShowRoundStudentsModal] = useState(false);
  const [selectedRound, setSelectedRound] = useState(null);
  const [selectedJobForRoundView, setSelectedJobForRoundView] = useState(null);
  const [showManageRoundsModal, setShowManageRoundsModal] = useState(false);
  const [selectedDriveForRounds, setSelectedDriveForRounds] = useState(null);
  const [selectedRoundForManagement, setSelectedRoundForManagement] =
    useState(null);
  const [roundApplicants, setRoundApplicants] = useState([]);
  const [selectedStudentsForRound, setSelectedStudentsForRound] = useState([]);
  const [loadingApplicants, setLoadingApplicants] = useState(false);

  // Deletion confirmation modal states
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [deleteTarget, setDeleteTarget] = useState(null);
  const [deleteReason, setDeleteReason] = useState("");

  // Student deletion states
  const [showDeleteStudentModal, setShowDeleteStudentModal] = useState(false);
  const [deleteStudentIndex, setDeleteStudentIndex] = useState(null);

  // Helper function to count placed students (matches PO dashboard logic)
  const getPlacedStudentsCount = (drive) => {
    // Check if drive has ended first
    const driveEnded = isDriveEnded(drive);
    
    // Only count from selection rounds if drive has ended
    if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
      const lastRound = drive.selectionRounds[drive.selectionRounds.length - 1];
      const countFromRounds = lastRound.selectedStudents?.length || 0;
      if (countFromRounds > 0) {
        return countFromRounds;
      }
    }
    
    // Always allow manual placed students (regardless of drive end date)
    return drive.placedStudents?.length || 0;
  };

  // Socket connection and real-time updates
  useSocketConnection(user?.role);

  // Handle real-time job drive updates
  useJobDriveUpdates((data) => {
    const { action } = data;

    // Refetch all job drives to get the latest data
    if (
      action === "created" ||
      action === "updated" ||
      action === "deleted" ||
      action === "application_submitted"
    ) {
      fetchAllJobDrives();
    }
  });

  // Handle real-time deletion request updates
  useDeletionRequestUpdates((data) => {
    const { action } = data;

    // Refetch all job drives when deletion is approved
    if (action === "approved") {
      fetchAllJobDrives();
    }
  });

  // Handle real-time application updates
  useApplicationUpdates((data) => {
    // Refetch drives when application status changes
    fetchAllJobDrives();
  });

  // Handle real-time modal updates
  useModalUpdates(selectedDrive?._id, (updatedDrive, action) => {
    if (action === 'updated') {
      // Update the selected drive data in the modal
      setSelectedDrive(updatedDrive);
    }
  });

  // Handle real-time round updates
  useRoundUpdates((data) => {
    const { action, jobDrive } = data;
    
    // If modal is open for this drive, refresh the selected drive data
    if (selectedDrive && jobDrive && (jobDrive._id === selectedDrive._id || jobDrive.id === selectedDrive._id)) {
      setSelectedDrive(jobDrive);
    }
    
    // If round management modal is open, refresh that too
    if (selectedDriveForRounds && jobDrive && (jobDrive._id === selectedDriveForRounds._id || jobDrive.id === selectedDriveForRounds._id)) {
      setSelectedDriveForRounds(jobDrive);
    }
    
    // Refresh the drives list
    fetchAllJobDrives();
  });

  // Add these helper functions at the top of the component
  const isDriveCreator = (drive) => {
    const isCreator = drive.createdBy?._id === user?.id;
    console.log("=== CREATOR CHECK ===");
    console.log("Drive:", drive.companyName);
    console.log("Drive creator ID:", drive.createdBy?._id);
    console.log("Current user ID:", user?.id);
    console.log("Is creator:", isCreator);
    return isCreator;
  };

  const canManageDrive = (drive) => {
    // If no createdBy info, nobody can manage
    if (!drive.createdBy) {
      console.log("❌ No creator info - no management access");
      return false;
    }

    // Check if user created the drive
    const isCreator = isDriveCreator(drive);

    // For PRs - also check department access
    if (user?.role === "placement_representative" || user?.role === "pr") {
      const userDept = normalizeDepartment(user.profile?.department);
      const creatorDept = normalizeDepartment(
        drive.createdBy?.profile?.department
      );

      console.log("=== MANAGE ACCESS CHECK ===");
      console.log("Drive:", drive.companyName);
      console.log("User:", user.email);
      console.log("User Dept (normalized):", userDept);
      console.log("Creator:", drive.createdBy.email);
      console.log("Creator Dept (normalized):", creatorDept);
      console.log("Is creator:", isCreator);

      // Allow if same department OR if user created the drive
      if (isCreator || (userDept && creatorDept && userDept === creatorDept)) {
        console.log(
          "✅ Management access granted - same department or creator"
        );
        return true;
      } else {
        console.log("❌ Different department and not creator - access denied");
        return false;
      }
    }

    // For POs - they can manage everything
    if (user?.role === "po" || user?.role === "placement_officer") {
      return true;
    }

    return isCreator;
  };

  const isViewOnlyPR = (drive) => {
    return (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      !canManageDrive(drive)
    );
  };

  // Function to check if applications are still open (for application deadline)
  const isApplicationDeadlinePassed = (drive) => {
    // If there's a deadline, use that; otherwise use drive date
    const checkDate = drive.deadline || drive.date;
    if (!checkDate) return false;

    const deadlineDateTime = new Date(checkDate);

    // If drive has a specific time, use it; otherwise assume end of day
    if (drive.time && drive.deadline) {
      const [hours, minutes] = drive.time.split(":");
      deadlineDateTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
    } else {
      // If no time specified, consider applications open until end of deadline day
      deadlineDateTime.setHours(23, 59, 59, 999);
    }

    const currentDateTime = new Date();
    return currentDateTime > deadlineDateTime;
  };

  // Function to check if drive has ended (for filtering purposes)
  const isDriveEnded = (drive) => {
    if (!drive.date) return false;

    const driveDate = new Date(drive.date);
    const currentDate = new Date();

    // If drive has time, use it for comparison
    if (drive.time) {
      const [hours, minutes] = drive.time.split(":").map(Number);
      driveDate.setHours(hours, minutes, 0, 0);
      return currentDate > driveDate;
    } else {
      // If no time specified, consider drive ended at end of day
      driveDate.setHours(23, 59, 59, 999);
      return currentDate > driveDate;
    }
  };

  const handleViewPlacedStudents = async (drive) => {
    try {
      const driveEnded = isDriveEnded(drive);
      
      // Only try to get students from selection rounds if drive has ended
      if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
        const token = localStorage.getItem("token");
        const response = await fetch(
          `http://localhost:5000/api/job-drives/${drive._id}/last-round-students`,
          {
            method: "GET",
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        if (response.ok) {
          const data = await response.json();
          if (data.students && data.students.length > 0) {
            // Create a drive object with the selection round students for modal display
            const driveWithRoundStudents = {
              ...drive,
              placedStudents: data.students, // Use students from final round
            };
            setSelectedDriveForView(driveWithRoundStudents);
            setShowPlacedStudentsViewModal(true);
            return;
          }
        }
      }

      // Always allow viewing manual placed students (regardless of drive end date)
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
        return;
      }

      // If no placed students found from either source
      toast.error("No placed students found for this drive");
    } catch (error) {
      console.error("Error fetching placed students:", error);
      // Fallback to showing manual placed students if API call fails
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
      } else {
        toast.error("Failed to fetch placed students");
      }
    }
  };

  useEffect(() => {
    // Wait for auth context to load before checking user
    if (user === null) {
      // Still loading auth state, don't redirect yet
      return;
    }

    // Allow both placement_representative and placement_officer
    if (
      !user ||
      (user.role !== "placement_representative" &&
        user.role !== "placement_officer" &&
        user.role !== "po")
    ) {
      navigate("/login");
      return;
    }
    fetchAllJobDrives();
  }, [user, navigate]);

  const fetchAllJobDrives = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem("token");
      const response = await axios.get("http://localhost:5000/api/job-drives", {
        headers: { Authorization: `Bearer ${token}` },
      });

      console.log("=== API RESPONSE DEBUG ===");
      console.log("Full response:", response.data);
      console.log("Job drives:", response.data.jobDrives);

      // Debug each drive's creator info
      response.data.jobDrives.forEach((drive, index) => {
        console.log(`Drive ${index + 1} (${drive.companyName}):`, {
          createdBy: drive.createdBy,
          createdById: drive.createdBy?._id,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      setDrives(response.data.jobDrives || []);
    } catch (error) {
      console.error("Error fetching job drives:", error);
      toast.error("Failed to fetch job drives");
    } finally {
      setLoading(false);
    }
  };

  // Add this useEffect to debug the data
  useEffect(() => {
    if (drives.length > 0) {
      console.log("=== DRIVES DEBUG ===");
      drives.forEach((drive, index) => {
        console.log(`Drive ${index + 1}:`, {
          company: drive.companyName,
          createdBy: drive.createdBy,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      console.log("Current user:", {
        role: user?.role,
        department: user?.profile?.department,
        profile: user?.profile,
      });
    }
  }, [drives, user]);

  const handleDeleteDrive = async (driveId) => {
    // Get drive details for the confirmation
    const drive = drives.find((d) => d._id === driveId);
    const driveName = drive
      ? `${drive.companyName} - ${drive.role}`
      : "this job drive";

    // Set up deletion target and show modal
    setDeleteTarget({
      id: driveId,
      name: driveName,
      drive: drive,
    });
    setShowDeleteModal(true);
  };

  const confirmDeleteDrive = async () => {
    if (!deleteTarget) return;

    // For PRs, validate reason
    if (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      (!deleteReason || deleteReason.trim() === "")
    ) {
      toast.error("Reason is required for deletion request");
      return;
    }

    try {
      const token = localStorage.getItem("token");

      // Use the new deletion request API
      await axios.post(
        "http://localhost:5000/api/deletion-requests/request",
        {
          jobDriveId: deleteTarget.id,
          reason: deleteReason || "Administrative deletion",
        },
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );

      if (user?.role === "po" || user?.role === "placement_officer") {
        toast.success("Job drive deleted successfully");
        setDrives(drives.filter((drive) => drive._id !== deleteTarget.id));
      } else {
        toast.success(
          "Deletion request submitted successfully. Awaiting PO approval."
        );
        // Don't remove from list as it's pending approval
      }

      // Close modal and reset state
      setShowDeleteModal(false);
      setDeleteTarget(null);
      setDeleteReason("");
    } catch (error) {
      console.error("Delete error:", error);
      if (error.response?.data?.message) {
        toast.error(error.response.data.message);
      } else {
        toast.error("Failed to process deletion request");
      }
    }
  };

  const cancelDelete = () => {
    setShowDeleteModal(false);
    setDeleteTarget(null);
    setDeleteReason("");
  };

  const handleEditDrive = (driveId) => {
    navigate(`/pr/edit-job/${driveId}?returnTo=/all-job-drives`);
  };

  const handleViewDetails = (drive) => {
    console.log("=== DRIVE DETAILS DEBUG ===");
    console.log("Full drive object:", JSON.stringify(drive, null, 2));
    console.log("Eligibility object:", drive.eligibility);
    console.log("Min CGPA field:", drive.eligibility?.minCGPA);
    console.log("CGPA field:", drive.eligibility?.cgpa);
    console.log("Test Details:", drive.testDetails);
    console.log("Interview Process:", drive.interviewProcess);
    console.log("Bond:", drive.bond);

    setSelectedDrive(drive);
    setShowModal(true);
  };

  const closeModal = () => {
    setShowModal(false);
    setSelectedDrive(null);
  };

  const getFilteredDrives = () => {
    console.log("=== ALL JOB DRIVES FILTERING ===");
    console.log("Total drives:", drives.length);
    console.log("Current filter:", filter);
    console.log("User role:", user?.role);

    return drives.filter((drive) => {
      const driveEnded = isDriveEnded(drive);
      console.log(
        `Drive ${drive.companyName}: ended=${driveEnded}, date=${drive.date}, time=${drive.time}`
      );

      if (filter === "upcoming") {
        return !driveEnded; // Not ended yet
      } else if (filter === "past") {
        return driveEnded; // Drive has ended
      }
      return true; // 'all' filter
    });
  };

  const handleEditStudent = (student, index) => {
    setEditingStudent(index);
    setEditStudentData({
      name: student.name,
      rollNumber: student.rollNumber,
      department: student.department || "",
      email: student.email,
      mobileNumber: student.mobileNumber || "",
    });
  };

  const handleSaveEdit = async (index) => {
    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/update-placed-student`,
        {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({
            index: index,
            studentData: editStudentData,
          }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student updated successfully!");
        setEditingStudent(null);

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to update student");
      }
    } catch (error) {
      console.error("Error updating student:", error);
      toast.error("Error updating student");
    }
  };

  const handleDeleteStudent = async (index) => {
    setDeleteStudentIndex(index);
    setShowDeleteStudentModal(true);
  };

  const confirmDeleteStudent = async () => {
    if (deleteStudentIndex === null) return;

    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/delete-placed-student`,
        {
          method: "DELETE",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({ index: deleteStudentIndex }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student deleted successfully!");

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to delete student");
      }
    } catch (error) {
      console.error("Error deleting student:", error);
      toast.error("Error deleting student");
    } finally {
      setShowDeleteStudentModal(false);
      setDeleteStudentIndex(null);
    }
  };

  const cancelDeleteStudent = () => {
    setShowDeleteStudentModal(false);
    setDeleteStudentIndex(null);
  };

  const downloadCSV = () => {
    if (!selectedDriveForView?.placedStudents?.length) {
      toast.error("No data to download");
      return;
    }

    const headers = [
      "S.No",
      "Name",
      "Roll Number",
      "Department",
      "Email",
      "Mobile",
      "Added On",
    ];
    const csvContent = [
      headers.join(","),
      ...selectedDriveForView.placedStudents.map((student, index) =>
        [
          index + 1,
          `"${student.name}"`,
          `"${student.rollNumber}"`,
          `"${student.department || "N/A"}"`,
          `"${student.email}"`,
          `"${student.mobileNumber || "N/A"}"`,
          `"${
            student.addedAt
              ? new Date(student.addedAt).toLocaleDateString()
              : "N/A"
          }"`,
        ].join(",")
      ),
    ].join("\n");

    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute(
      "download",
      `${selectedDriveForView.companyName}_placed_students.csv`
    );
    link.style.visibility = "hidden";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const handleManageRounds = (drive, roundIndex) => {
    // For same department PRs - full management access
    setSelectedJobForRounds(drive);
</original_code>```

```
import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../contexts/AuthContext";
import axios from "axios";
import toast from "react-hot-toast";
import PRJobCard from "./PRJobCard";
import RoundManagementModal from "./RoundManagementModal";
import {
  useJobDriveUpdates,
  useDeletionRequestUpdates,
  useApplicationUpdates,
  useSocketConnection,
  useModalUpdates,
  useRoundUpdates,
} from "../hooks/useSocket";

const normalizeDepartment = (dept) => {
  if (!dept) return null;
  return dept.toLowerCase().trim();
};

const AllJobDrives = () => {
  const { user } = useAuth();
  const navigate = useNavigate();
  const [drives, setDrives] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState("all");
  const [showModal, setShowModal] = useState(false);
  const [selectedDrive, setSelectedDrive] = useState(null);
  const [showPlacedStudentsViewModal, setShowPlacedStudentsViewModal] =
    useState(false);
  const [selectedDriveForView, setSelectedDriveForView] = useState(null);
  const [showRoundModal, setShowRoundModal] = useState(false);
  const [selectedJobForRounds, setSelectedJobForRounds] = useState(null);
  const [selectedRoundIndex, setSelectedRoundIndex] = useState(null);
  const [showRoundStudentsModal, setShowRoundStudentsModal] = useState(false);
  const [selectedRound, setSelectedRound] = useState(null);
  const [selectedJobForRoundView, setSelectedJobForRoundView] = useState(null);
  const [showManageRoundsModal, setShowManageRoundsModal] = useState(false);
  const [selectedDriveForRounds, setSelectedDriveForRounds] = useState(null);
  const [selectedRoundForManagement, setSelectedRoundForManagement] =
    useState(null);
  const [roundApplicants, setRoundApplicants] = useState([]);
  const [selectedStudentsForRound, setSelectedStudentsForRound] = useState([]);
  const [loadingApplicants, setLoadingApplicants] = useState(false);

  // Deletion confirmation modal states
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [deleteTarget, setDeleteTarget] = useState(null);
  const [deleteReason, setDeleteReason] = useState("");

  // Student deletion states
  const [showDeleteStudentModal, setShowDeleteStudentModal] = useState(false);
  const [deleteStudentIndex, setDeleteStudentIndex] = useState(null);

  // Helper function to count placed students (matches PO dashboard logic)
  const getPlacedStudentsCount = (drive) => {
    // Check if drive has ended first
    const driveEnded = isDriveEnded(drive);
    
    // Only count from selection rounds if drive has ended
    if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
      const lastRound = drive.selectionRounds[drive.selectionRounds.length - 1];
      const countFromRounds = lastRound.selectedStudents?.length || 0;
      if (countFromRounds > 0) {
        return countFromRounds;
      }
    }
    
    // Always allow manual placed students (regardless of drive end date)
    return drive.placedStudents?.length || 0;
  };

  // Socket connection and real-time updates
  useSocketConnection(user?.role);

  // Handle real-time job drive updates
  useJobDriveUpdates((data) => {
    const { action } = data;

    // Refetch all job drives to get the latest data
    if (
      action === "created" ||
      action === "updated" ||
      action === "deleted" ||
      action === "application_submitted"
    ) {
      fetchAllJobDrives();
    }
  });

  // Handle real-time deletion request updates
  useDeletionRequestUpdates((data) => {
    const { action } = data;

    // Refetch all job drives when deletion is approved
    if (action === "approved") {
      fetchAllJobDrives();
    }
  });

  // Handle real-time application updates
  useApplicationUpdates((data) => {
    // Refetch drives when application status changes
    fetchAllJobDrives();
  });

  // Handle real-time modal updates
  useModalUpdates(selectedDrive?._id, (updatedDrive, action) => {
    if (action === 'updated') {
      // Update the selected drive data in the modal
      setSelectedDrive(updatedDrive);
    }
  });

  // Handle real-time round updates
  useRoundUpdates((data) => {
    const { action, jobDrive } = data;
    
    // If modal is open for this drive, refresh the selected drive data
    if (selectedDrive && jobDrive && (jobDrive._id === selectedDrive._id || jobDrive.id === selectedDrive._id)) {
      setSelectedDrive(jobDrive);
    }
    
    // If round management modal is open, refresh that too
    if (selectedDriveForRounds && jobDrive && (jobDrive._id === selectedDriveForRounds._id || jobDrive.id === selectedDriveForRounds._id)) {
      setSelectedDriveForRounds(jobDrive);
    }
    
    // Refresh the drives list
    fetchAllJobDrives();
  });

  // Add these helper functions at the top of the component
  const isDriveCreator = (drive) => {
    const isCreator = drive.createdBy?._id === user?.id;
    console.log("=== CREATOR CHECK ===");
    console.log("Drive:", drive.companyName);
    console.log("Drive creator ID:", drive.createdBy?._id);
    console.log("Current user ID:", user?.id);
    console.log("Is creator:", isCreator);
    return isCreator;
  };

  const canManageDrive = (drive) => {
    // If no createdBy info, nobody can manage
    if (!drive.createdBy) {
      console.log("❌ No creator info - no management access");
      return false;
    }

    // Check if user created the drive
    const isCreator = isDriveCreator(drive);

    // For PRs - also check department access
    if (user?.role === "placement_representative" || user?.role === "pr") {
      const userDept = normalizeDepartment(user.profile?.department);
      const creatorDept = normalizeDepartment(
        drive.createdBy?.profile?.department
      );

      console.log("=== MANAGE ACCESS CHECK ===");
      console.log("Drive:", drive.companyName);
      console.log("User:", user.email);
      console.log("User Dept (normalized):", userDept);
      console.log("Creator:", drive.createdBy.email);
      console.log("Creator Dept (normalized):", creatorDept);
      console.log("Is creator:", isCreator);

      // Allow if same department OR if user created the drive
      if (isCreator || (userDept && creatorDept && userDept === creatorDept)) {
        console.log(
          "✅ Management access granted - same department or creator"
        );
        return true;
      } else {
        console.log("❌ Different department and not creator - access denied");
        return false;
      }
    }

    // For POs - they can manage everything
    if (user?.role === "po" || user?.role === "placement_officer") {
      return true;
    }

    return isCreator;
  };

  const isViewOnlyPR = (drive) => {
    return (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      !canManageDrive(drive)
    );
  };

  // Function to check if applications are still open (for application deadline)
  const isApplicationDeadlinePassed = (drive) => {
    // If there's a deadline, use that; otherwise use drive date
    const checkDate = drive.deadline || drive.date;
    if (!checkDate) return false;

    const deadlineDateTime = new Date(checkDate);

    // If drive has a specific time, use it; otherwise assume end of day
    if (drive.time && drive.deadline) {
      const [hours, minutes] = drive.time.split(":");
      deadlineDateTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
    } else {
      // If no time specified, consider applications open until end of deadline day
      deadlineDateTime.setHours(23, 59, 59, 999);
    }

    const currentDateTime = new Date();
    return currentDateTime > deadlineDateTime;
  };

  // Function to check if drive has ended (for filtering purposes)
  const isDriveEnded = (drive) => {
    if (!drive.date) return false;

    const driveDate = new Date(drive.date);
    const currentDate = new Date();

    // If drive has time, use it for comparison
    if (drive.time) {
      const [hours, minutes] = drive.time.split(":").map(Number);
      driveDate.setHours(hours, minutes, 0, 0);
      return currentDate > driveDate;
    } else {
      // If no time specified, consider drive ended at end of day
      driveDate.setHours(23, 59, 59, 999);
      return currentDate > driveDate;
    }
  };

  const handleViewPlacedStudents = async (drive) => {
    try {
      const driveEnded = isDriveEnded(drive);
      
      // Only try to get students from selection rounds if drive has ended
      if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
        const token = localStorage.getItem("token");
        const response = await fetch(
          `http://localhost:5000/api/job-drives/${drive._id}/last-round-students`,
          {
            method: "GET",
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        if (response.ok) {
          const data = await response.json();
          if (data.students && data.students.length > 0) {
            // Create a drive object with the selection round students for modal display
            const driveWithRoundStudents = {
              ...drive,
              placedStudents: data.students, // Use students from final round
            };
            setSelectedDriveForView(driveWithRoundStudents);
            setShowPlacedStudentsViewModal(true);
            return;
          }
        }
      }

      // Always allow viewing manual placed students (regardless of drive end date)
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
        return;
      }

      // If no placed students found from either source
      toast.error("No placed students found for this drive");
    } catch (error) {
      console.error("Error fetching placed students:", error);
      // Fallback to showing manual placed students if API call fails
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
      } else {
        toast.error("Failed to fetch placed students");
      }
    }
  };

  useEffect(() => {
    // Wait for auth context to load before checking user
    if (user === null) {
      // Still loading auth state, don't redirect yet
      return;
    }

    // Allow both placement_representative and placement_officer
    if (
      !user ||
      (user.role !== "placement_representative" &&
        user.role !== "placement_officer" &&
        user.role !== "po")
    ) {
      navigate("/login");
      return;
    }
    fetchAllJobDrives();
  }, [user, navigate]);

  const fetchAllJobDrives = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem("token");
      const response = await axios.get("http://localhost:5000/api/job-drives", {
        headers: { Authorization: `Bearer ${token}` },
      });

      console.log("=== API RESPONSE DEBUG ===");
      console.log("Full response:", response.data);
      console.log("Job drives:", response.data.jobDrives);

      // Debug each drive's creator info
      response.data.jobDrives.forEach((drive, index) => {
        console.log(`Drive ${index + 1} (${drive.companyName}):`, {
          createdBy: drive.createdBy,
          createdById: drive.createdBy?._id,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      setDrives(response.data.jobDrives || []);
    } catch (error) {
      console.error("Error fetching job drives:", error);
      toast.error("Failed to fetch job drives");
    } finally {
      setLoading(false);
    }
  };

  // Add this useEffect to debug the data
  useEffect(() => {
    if (drives.length > 0) {
      console.log("=== DRIVES DEBUG ===");
      drives.forEach((drive, index) => {
        console.log(`Drive ${index + 1}:`, {
          company: drive.companyName,
          createdBy: drive.createdBy,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      console.log("Current user:", {
        role: user?.role,
        department: user?.profile?.department,
        profile: user?.profile,
      });
    }
  }, [drives, user]);

  const handleDeleteDrive = async (driveId) => {
    // Get drive details for the confirmation
    const drive = drives.find((d) => d._id === driveId);
    const driveName = drive
      ? `${drive.companyName} - ${drive.role}`
      : "this job drive";

    // Set up deletion target and show modal
    setDeleteTarget({
      id: driveId,
      name: driveName,
      drive: drive,
    });
    setShowDeleteModal(true);
  };

  const confirmDeleteDrive = async () => {
    if (!deleteTarget) return;

    // For PRs, validate reason
    if (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      (!deleteReason || deleteReason.trim() === "")
    ) {
      toast.error("Reason is required for deletion request");
      return;
    }

    try {
      const token = localStorage.getItem("token");

      // Use the new deletion request API
      await axios.post(
        "http://localhost:5000/api/deletion-requests/request",
        {
          jobDriveId: deleteTarget.id,
          reason: deleteReason || "Administrative deletion",
        },
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );

      if (user?.role === "po" || user?.role === "placement_officer") {
        toast.success("Job drive deleted successfully");
        setDrives(drives.filter((drive) => drive._id !== deleteTarget.id));
      } else {
        toast.success(
          "Deletion request submitted successfully. Awaiting PO approval."
        );
        // Don't remove from list as it's pending approval
      }

      // Close modal and reset state
      setShowDeleteModal(false);
      setDeleteTarget(null);
      setDeleteReason("");
    } catch (error) {
      console.error("Delete error:", error);
      if (error.response?.data?.message) {
        toast.error(error.response.data.message);
      } else {
        toast.error("Failed to process deletion request");
      }
    }
  };

  const cancelDelete = () => {
    setShowDeleteModal(false);
    setDeleteTarget(null);
    setDeleteReason("");
  };

  const handleEditDrive = (driveId) => {
    navigate(`/pr/edit-job/${driveId}?returnTo=/all-job-drives`);
  };

  const handleViewDetails = (drive) => {
    console.log("=== DRIVE DETAILS DEBUG ===");
    console.log("Full drive object:", JSON.stringify(drive, null, 2));
    console.log("Eligibility object:", drive.eligibility);
    console.log("Min CGPA field:", drive.eligibility?.minCGPA);
    console.log("CGPA field:", drive.eligibility?.cgpa);
    console.log("Test Details:", drive.testDetails);
    console.log("Interview Process:", drive.interviewProcess);
    console.log("Bond:", drive.bond);

    setSelectedDrive(drive);
    setShowModal(true);
  };

  const closeModal = () => {
    setShowModal(false);
    setSelectedDrive(null);
  };

  const getFilteredDrives = () => {
    console.log("=== ALL JOB DRIVES FILTERING ===");
    console.log("Total drives:", drives.length);
    console.log("Current filter:", filter);
    console.log("User role:", user?.role);

    return drives.filter((drive) => {
      const driveEnded = isDriveEnded(drive);
      console.log(
        `Drive ${drive.companyName}: ended=${driveEnded}, date=${drive.date}, time=${drive.time}`
      );

      if (filter === "upcoming") {
        return !driveEnded; // Not ended yet
      } else if (filter === "past") {
        return driveEnded; // Drive has ended
      }
      return true; // 'all' filter
    });
  };

  const handleEditStudent = (student, index) => {
    setEditingStudent(index);
    setEditStudentData({
      name: student.name,
      rollNumber: student.rollNumber,
      department: student.department || "",
      email: student.email,
      mobileNumber: student.mobileNumber || "",
    });
  };

  const handleSaveEdit = async (index) => {
    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/update-placed-student`,
        {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({
            index: index,
            studentData: editStudentData,
          }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student updated successfully!");
        setEditingStudent(null);

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to update student");
      }
    } catch (error) {
      console.error("Error updating student:", error);
      toast.error("Error updating student");
    }
  };

  const handleDeleteStudent = async (index) => {
    setDeleteStudentIndex(index);
    setShowDeleteStudentModal(true);
  };

  const confirmDeleteStudent = async () => {
    if (deleteStudentIndex === null) return;

    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/delete-placed-student`,
        {
          method: "DELETE",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({ index: deleteStudentIndex }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student deleted successfully!");

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to delete student");
      }
    } catch (error) {
      console.error("Error deleting student:", error);
      toast.error("Error deleting student");
    } finally {
      setShowDeleteStudentModal(false);
      setDeleteStudentIndex(null);
    }
  };

  const cancelDeleteStudent = () => {
    setShowDeleteStudentModal(false);
    setDeleteStudentIndex(null);
  };

  const downloadCSV = () => {
    if (!selectedDriveForView?.placedStudents?.length) {
      toast.error("No data to download");
      return;
    }

    const headers = [
      "S.No",
      "Name",
      "Roll Number",
      "Department",
      "Email",
      "Mobile",
      "Added On",
    ];
    const csvContent = [
      headers.join(","),
      ...selectedDriveForView.placedStudents.map((student, index) =>
        [
          index + 1,
          `"${student.name}"`,
          `"${student.rollNumber}"`,
          `"${student.department || "N/A"}"`,
          `"${student.email}"`,
          `"${student.mobileNumber || "N/A"}"`,
          `"${
            student.addedAt
              ? new Date(student.addedAt).toLocaleDateString()
              : "N/A"
          }"`,
        ].join(",")
      ),
    ].join("\n");

    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute(
      "download",
      `${selectedDriveForView.companyName}_placed_students.csv`
    );
    link.style.visibility = "hidden";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const handleManageRounds = (drive, roundIndex) => {
    // For same department PRs - full management access
    setSelectedJobForRounds(drive);
</original_code>```

```
import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../contexts/AuthContext";
import axios from "axios";
import toast from "react-hot-toast";
import PRJobCard from "./PRJobCard";
import RoundManagementModal from "./RoundManagementModal";
import {
  useJobDriveUpdates,
  useDeletionRequestUpdates,
  useApplicationUpdates,
  useSocketConnection,
  useModalUpdates,
  useRoundUpdates,
} from "../hooks/useSocket";

const normalizeDepartment = (dept) => {
  if (!dept) return null;
  return dept.toLowerCase().trim();
};

const AllJobDrives = () => {
  const { user } = useAuth();
  const navigate = useNavigate();
  const [drives, setDrives] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState("all");
  const [showModal, setShowModal] = useState(false);
  const [selectedDrive, setSelectedDrive] = useState(null);
  const [showPlacedStudentsViewModal, setShowPlacedStudentsViewModal] =
    useState(false);
  const [selectedDriveForView, setSelectedDriveForView] = useState(null);
  const [showRoundModal, setShowRoundModal] = useState(false);
  const [selectedJobForRounds, setSelectedJobForRounds] = useState(null);
  const [selectedRoundIndex, setSelectedRoundIndex] = useState(null);
  const [showRoundStudentsModal, setShowRoundStudentsModal] = useState(false);
  const [selectedRound, setSelectedRound] = useState(null);
  const [selectedJobForRoundView, setSelectedJobForRoundView] = useState(null);
  const [showManageRoundsModal, setShowManageRoundsModal] = useState(false);
  const [selectedDriveForRounds, setSelectedDriveForRounds] = useState(null);
  const [selectedRoundForManagement, setSelectedRoundForManagement] =
    useState(null);
  const [roundApplicants, setRoundApplicants] = useState([]);
  const [selectedStudentsForRound, setSelectedStudentsForRound] = useState([]);
  const [loadingApplicants, setLoadingApplicants] = useState(false);

  // Deletion confirmation modal states
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [deleteTarget, setDeleteTarget] = useState(null);
  const [deleteReason, setDeleteReason] = useState("");

  // Student deletion states
  const [showDeleteStudentModal, setShowDeleteStudentModal] = useState(false);
  const [deleteStudentIndex, setDeleteStudentIndex] = useState(null);

  // Helper function to count placed students (matches PO dashboard logic)
  const getPlacedStudentsCount = (drive) => {
    // Check if drive has ended first
    const driveEnded = isDriveEnded(drive);
    
    // Only count from selection rounds if drive has ended
    if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
      const lastRound = drive.selectionRounds[drive.selectionRounds.length - 1];
      const countFromRounds = lastRound.selectedStudents?.length || 0;
      if (countFromRounds > 0) {
        return countFromRounds;
      }
    }
    
    // Always allow manual placed students (regardless of drive end date)
    return drive.placedStudents?.length || 0;
  };

  // Socket connection and real-time updates
  useSocketConnection(user?.role);

  // Handle real-time job drive updates
  useJobDriveUpdates((data) => {
    const { action } = data;

    // Refetch all job drives to get the latest data
    if (
      action === "created" ||
      action === "updated" ||
      action === "deleted" ||
      action === "application_submitted"
    ) {
      fetchAllJobDrives();
    }
  });

  // Handle real-time deletion request updates
  useDeletionRequestUpdates((data) => {
    const { action } = data;

    // Refetch all job drives when deletion is approved
    if (action === "approved") {
      fetchAllJobDrives();
    }
  });

  // Handle real-time application updates
  useApplicationUpdates((data) => {
    // Refetch drives when application status changes
    fetchAllJobDrives();
  });

  // Handle real-time modal updates
  useModalUpdates(selectedDrive?._id, (updatedDrive, action) => {
    if (action === 'updated') {
      // Update the selected drive data in the modal
      setSelectedDrive(updatedDrive);
    }
  });

  // Handle real-time round updates
  useRoundUpdates((data) => {
    const { action, jobDrive } = data;
    
    // If modal is open for this drive, refresh the selected drive data
    if (selectedDrive && jobDrive && (jobDrive._id === selectedDrive._id || jobDrive.id === selectedDrive._id)) {
      setSelectedDrive(jobDrive);
    }
    
    // If round management modal is open, refresh that too
    if (selectedDriveForRounds && jobDrive && (jobDrive._id === selectedDriveForRounds._id || jobDrive.id === selectedDriveForRounds._id)) {
      setSelectedDriveForRounds(jobDrive);
    }
    
    // Refresh the drives list
    fetchAllJobDrives();
  });

  // Add these helper functions at the top of the component
  const isDriveCreator = (drive) => {
    const isCreator = drive.createdBy?._id === user?.id;
    console.log("=== CREATOR CHECK ===");
    console.log("Drive:", drive.companyName);
    console.log("Drive creator ID:", drive.createdBy?._id);
    console.log("Current user ID:", user?.id);
    console.log("Is creator:", isCreator);
    return isCreator;
  };

  const canManageDrive = (drive) => {
    // If no createdBy info, nobody can manage
    if (!drive.createdBy) {
      console.log("❌ No creator info - no management access");
      return false;
    }

    // Check if user created the drive
    const isCreator = isDriveCreator(drive);

    // For PRs - also check department access
    if (user?.role === "placement_representative" || user?.role === "pr") {
      const userDept = normalizeDepartment(user.profile?.department);
      const creatorDept = normalizeDepartment(
        drive.createdBy?.profile?.department
      );

      console.log("=== MANAGE ACCESS CHECK ===");
      console.log("Drive:", drive.companyName);
      console.log("User:", user.email);
      console.log("User Dept (normalized):", userDept);
      console.log("Creator:", drive.createdBy.email);
      console.log("Creator Dept (normalized):", creatorDept);
      console.log("Is creator:", isCreator);

      // Allow if same department OR if user created the drive
      if (isCreator || (userDept && creatorDept && userDept === creatorDept)) {
        console.log(
          "✅ Management access granted - same department or creator"
        );
        return true;
      } else {
        console.log("❌ Different department and not creator - access denied");
        return false;
      }
    }

    // For POs - they can manage everything
    if (user?.role === "po" || user?.role === "placement_officer") {
      return true;
    }

    return isCreator;
  };

  const isViewOnlyPR = (drive) => {
    return (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      !canManageDrive(drive)
    );
  };

  // Function to check if applications are still open (for application deadline)
  const isApplicationDeadlinePassed = (drive) => {
    // If there's a deadline, use that; otherwise use drive date
    const checkDate = drive.deadline || drive.date;
    if (!checkDate) return false;

    const deadlineDateTime = new Date(checkDate);

    // If drive has a specific time, use it; otherwise assume end of day
    if (drive.time && drive.deadline) {
      const [hours, minutes] = drive.time.split(":");
      deadlineDateTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
    } else {
      // If no time specified, consider applications open until end of deadline day
      deadlineDateTime.setHours(23, 59, 59, 999);
    }

    const currentDateTime = new Date();
    return currentDateTime > deadlineDateTime;
  };

  // Function to check if drive has ended (for filtering purposes)
  const isDriveEnded = (drive) => {
    if (!drive.date) return false;

    const driveDate = new Date(drive.date);
    const currentDate = new Date();

    // If drive has time, use it for comparison
    if (drive.time) {
      const [hours, minutes] = drive.time.split(":").map(Number);
      driveDate.setHours(hours, minutes, 0, 0);
      return currentDate > driveDate;
    } else {
      // If no time specified, consider drive ended at end of day
      driveDate.setHours(23, 59, 59, 999);
      return currentDate > driveDate;
    }
  };

  const handleViewPlacedStudents = async (drive) => {
    try {
      const driveEnded = isDriveEnded(drive);
      
      // Only try to get students from selection rounds if drive has ended
      if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
        const token = localStorage.getItem("token");
        const response = await fetch(
          `http://localhost:5000/api/job-drives/${drive._id}/last-round-students`,
          {
            method: "GET",
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        if (response.ok) {
          const data = await response.json();
          if (data.students && data.students.length > 0) {
            // Create a drive object with the selection round students for modal display
            const driveWithRoundStudents = {
              ...drive,
              placedStudents: data.students, // Use students from final round
            };
            setSelectedDriveForView(driveWithRoundStudents);
            setShowPlacedStudentsViewModal(true);
            return;
          }
        }
      }

      // Always allow viewing manual placed students (regardless of drive end date)
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
        return;
      }

      // If no placed students found from either source
      toast.error("No placed students found for this drive");
    } catch (error) {
      console.error("Error fetching placed students:", error);
      // Fallback to showing manual placed students if API call fails
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
      } else {
        toast.error("Failed to fetch placed students");
      }
    }
  };

  useEffect(() => {
    // Wait for auth context to load before checking user
    if (user === null) {
      // Still loading auth state, don't redirect yet
      return;
    }

    // Allow both placement_representative and placement_officer
    if (
      !user ||
      (user.role !== "placement_representative" &&
        user.role !== "placement_officer" &&
        user.role !== "po")
    ) {
      navigate("/login");
      return;
    }
    fetchAllJobDrives();
  }, [user, navigate]);

  const fetchAllJobDrives = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem("token");
      const response = await axios.get("http://localhost:5000/api/job-drives", {
        headers: { Authorization: `Bearer ${token}` },
      });

      console.log("=== API RESPONSE DEBUG ===");
      console.log("Full response:", response.data);
      console.log("Job drives:", response.data.jobDrives);

      // Debug each drive's creator info
      response.data.jobDrives.forEach((drive, index) => {
        console.log(`Drive ${index + 1} (${drive.companyName}):`, {
          createdBy: drive.createdBy,
          createdById: drive.createdBy?._id,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      setDrives(response.data.jobDrives || []);
    } catch (error) {
      console.error("Error fetching job drives:", error);
      toast.error("Failed to fetch job drives");
    } finally {
      setLoading(false);
    }
  };

  // Add this useEffect to debug the data
  useEffect(() => {
    if (drives.length > 0) {
      console.log("=== DRIVES DEBUG ===");
      drives.forEach((drive, index) => {
        console.log(`Drive ${index + 1}:`, {
          company: drive.companyName,
          createdBy: drive.createdBy,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      console.log("Current user:", {
        role: user?.role,
        department: user?.profile?.department,
        profile: user?.profile,
      });
    }
  }, [drives, user]);

  const handleDeleteDrive = async (driveId) => {
    // Get drive details for the confirmation
    const drive = drives.find((d) => d._id === driveId);
    const driveName = drive
      ? `${drive.companyName} - ${drive.role}`
      : "this job drive";

    // Set up deletion target and show modal
    setDeleteTarget({
      id: driveId,
      name: driveName,
      drive: drive,
    });
    setShowDeleteModal(true);
  };

  const confirmDeleteDrive = async () => {
    if (!deleteTarget) return;

    // For PRs, validate reason
    if (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      (!deleteReason || deleteReason.trim() === "")
    ) {
      toast.error("Reason is required for deletion request");
      return;
    }

    try {
      const token = localStorage.getItem("token");

      // Use the new deletion request API
      await axios.post(
        "http://localhost:5000/api/deletion-requests/request",
        {
          jobDriveId: deleteTarget.id,
          reason: deleteReason || "Administrative deletion",
        },
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );

      if (user?.role === "po" || user?.role === "placement_officer") {
        toast.success("Job drive deleted successfully");
        setDrives(drives.filter((drive) => drive._id !== deleteTarget.id));
      } else {
        toast.success(
          "Deletion request submitted successfully. Awaiting PO approval."
        );
        // Don't remove from list as it's pending approval
      }

      // Close modal and reset state
      setShowDeleteModal(false);
      setDeleteTarget(null);
      setDeleteReason("");
    } catch (error) {
      console.error("Delete error:", error);
      if (error.response?.data?.message) {
        toast.error(error.response.data.message);
      } else {
        toast.error("Failed to process deletion request");
      }
    }
  };

  const cancelDelete = () => {
    setShowDeleteModal(false);
    setDeleteTarget(null);
    setDeleteReason("");
  };

  const handleEditDrive = (driveId) => {
    navigate(`/pr/edit-job/${driveId}?returnTo=/all-job-drives`);
  };

  const handleViewDetails = (drive) => {
    console.log("=== DRIVE DETAILS DEBUG ===");
    console.log("Full drive object:", JSON.stringify(drive, null, 2));
    console.log("Eligibility object:", drive.eligibility);
    console.log("Min CGPA field:", drive.eligibility?.minCGPA);
    console.log("CGPA field:", drive.eligibility?.cgpa);
    console.log("Test Details:", drive.testDetails);
    console.log("Interview Process:", drive.interviewProcess);
    console.log("Bond:", drive.bond);

    setSelectedDrive(drive);
    setShowModal(true);
  };

  const closeModal = () => {
    setShowModal(false);
    setSelectedDrive(null);
  };

  const getFilteredDrives = () => {
    console.log("=== ALL JOB DRIVES FILTERING ===");
    console.log("Total drives:", drives.length);
    console.log("Current filter:", filter);
    console.log("User role:", user?.role);

    return drives.filter((drive) => {
      const driveEnded = isDriveEnded(drive);
      console.log(
        `Drive ${drive.companyName}: ended=${driveEnded}, date=${drive.date}, time=${drive.time}`
      );

      if (filter === "upcoming") {
        return !driveEnded; // Not ended yet
      } else if (filter === "past") {
        return driveEnded; // Drive has ended
      }
      return true; // 'all' filter
    });
  };

  const handleEditStudent = (student, index) => {
    setEditingStudent(index);
    setEditStudentData({
      name: student.name,
      rollNumber: student.rollNumber,
      department: student.department || "",
      email: student.email,
      mobileNumber: student.mobileNumber || "",
    });
  };

  const handleSaveEdit = async (index) => {
    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/update-placed-student`,
        {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({
            index: index,
            studentData: editStudentData,
          }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student updated successfully!");
        setEditingStudent(null);

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to update student");
      }
    } catch (error) {
      console.error("Error updating student:", error);
      toast.error("Error updating student");
    }
  };

  const handleDeleteStudent = async (index) => {
    setDeleteStudentIndex(index);
    setShowDeleteStudentModal(true);
  };

  const confirmDeleteStudent = async () => {
    if (deleteStudentIndex === null) return;

    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/delete-placed-student`,
        {
          method: "DELETE",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({ index: deleteStudentIndex }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student deleted successfully!");

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to delete student");
      }
    } catch (error) {
      console.error("Error deleting student:", error);
      toast.error("Error deleting student");
    } finally {
      setShowDeleteStudentModal(false);
      setDeleteStudentIndex(null);
    }
  };

  const cancelDeleteStudent = () => {
    setShowDeleteStudentModal(false);
    setDeleteStudentIndex(null);
  };

  const downloadCSV = () => {
    if (!selectedDriveForView?.placedStudents?.length) {
      toast.error("No data to download");
      return;
    }

    const headers = [
      "S.No",
      "Name",
      "Roll Number",
      "Department",
      "Email",
      "Mobile",
      "Added On",
    ];
    const csvContent = [
      headers.join(","),
      ...selectedDriveForView.placedStudents.map((student, index) =>
        [
          index + 1,
          `"${student.name}"`,
          `"${student.rollNumber}"`,
          `"${student.department || "N/A"}"`,
          `"${student.email}"`,
          `"${student.mobileNumber || "N/A"}"`,
          `"${
            student.addedAt
              ? new Date(student.addedAt).toLocaleDateString()
              : "N/A"
          }"`,
        ].join(",")
      ),
    ].join("\n");

    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute(
      "download",
      `${selectedDriveForView.companyName}_placed_students.csv`
    );
    link.style.visibility = "hidden";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const handleManageRounds = (drive, roundIndex) => {
    // For same department PRs - full management access
    setSelectedJobForRounds(drive);
</original_code>```

```
import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../contexts/AuthContext";
import axios from "axios";
import toast from "react-hot-toast";
import PRJobCard from "./PRJobCard";
import RoundManagementModal from "./RoundManagementModal";
import {
  useJobDriveUpdates,
  useDeletionRequestUpdates,
  useApplicationUpdates,
  useSocketConnection,
  useModalUpdates,
  useRoundUpdates,
} from "../hooks/useSocket";

const normalizeDepartment = (dept) => {
  if (!dept) return null;
  return dept.toLowerCase().trim();
};

const AllJobDrives = () => {
  const { user } = useAuth();
  const navigate = useNavigate();
  const [drives, setDrives] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState("all");
  const [showModal, setShowModal] = useState(false);
  const [selectedDrive, setSelectedDrive] = useState(null);
  const [showPlacedStudentsViewModal, setShowPlacedStudentsViewModal] =
    useState(false);
  const [selectedDriveForView, setSelectedDriveForView] = useState(null);
  const [showRoundModal, setShowRoundModal] = useState(false);
  const [selectedJobForRounds, setSelectedJobForRounds] = useState(null);
  const [selectedRoundIndex, setSelectedRoundIndex] = useState(null);
  const [showRoundStudentsModal, setShowRoundStudentsModal] = useState(false);
  const [selectedRound, setSelectedRound] = useState(null);
  const [selectedJobForRoundView, setSelectedJobForRoundView] = useState(null);
  const [showManageRoundsModal, setShowManageRoundsModal] = useState(false);
  const [selectedDriveForRounds, setSelectedDriveForRounds] = useState(null);
  const [selectedRoundForManagement, setSelectedRoundForManagement] =
    useState(null);
  const [roundApplicants, setRoundApplicants] = useState([]);
  const [selectedStudentsForRound, setSelectedStudentsForRound] = useState([]);
  const [loadingApplicants, setLoadingApplicants] = useState(false);

  // Deletion confirmation modal states
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [deleteTarget, setDeleteTarget] = useState(null);
  const [deleteReason, setDeleteReason] = useState("");

  // Student deletion states
  const [showDeleteStudentModal, setShowDeleteStudentModal] = useState(false);
  const [deleteStudentIndex, setDeleteStudentIndex] = useState(null);

  // Helper function to count placed students (matches PO dashboard logic)
  const getPlacedStudentsCount = (drive) => {
    // Check if drive has ended first
    const driveEnded = isDriveEnded(drive);
    
    // Only count from selection rounds if drive has ended
    if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
      const lastRound = drive.selectionRounds[drive.selectionRounds.length - 1];
      const countFromRounds = lastRound.selectedStudents?.length || 0;
      if (countFromRounds > 0) {
        return countFromRounds;
      }
    }
    
    // Always allow manual placed students (regardless of drive end date)
    return drive.placedStudents?.length || 0;
  };

  // Socket connection and real-time updates
  useSocketConnection(user?.role);

  // Handle real-time job drive updates
  useJobDriveUpdates((data) => {
    const { action } = data;

    // Refetch all job drives to get the latest data
    if (
      action === "created" ||
      action === "updated" ||
      action === "deleted" ||
      action === "application_submitted"
    ) {
      fetchAllJobDrives();
    }
  });

  // Handle real-time deletion request updates
  useDeletionRequestUpdates((data) => {
    const { action } = data;

    // Refetch all job drives when deletion is approved
    if (action === "approved") {
      fetchAllJobDrives();
    }
  });

  // Handle real-time application updates
  useApplicationUpdates((data) => {
    // Refetch drives when application status changes
    fetchAllJobDrives();
  });

  // Handle real-time modal updates
  useModalUpdates(selectedDrive?._id, (updatedDrive, action) => {
    if (action === 'updated') {
      // Update the selected drive data in the modal
      setSelectedDrive(updatedDrive);
    }
  });

  // Handle real-time round updates
  useRoundUpdates((data) => {
    const { action, jobDrive } = data;
    
    // If modal is open for this drive, refresh the selected drive data
    if (selectedDrive && jobDrive && (jobDrive._id === selectedDrive._id || jobDrive.id === selectedDrive._id)) {
      setSelectedDrive(jobDrive);
    }
    
    // If round management modal is open, refresh that too
    if (selectedDriveForRounds && jobDrive && (jobDrive._id === selectedDriveForRounds._id || jobDrive.id === selectedDriveForRounds._id)) {
      setSelectedDriveForRounds(jobDrive);
    }
    
    // Refresh the drives list
    fetchAllJobDrives();
  });

  // Add these helper functions at the top of the component
  const isDriveCreator = (drive) => {
    const isCreator = drive.createdBy?._id === user?.id;
    console.log("=== CREATOR CHECK ===");
    console.log("Drive:", drive.companyName);
    console.log("Drive creator ID:", drive.createdBy?._id);
    console.log("Current user ID:", user?.id);
    console.log("Is creator:", isCreator);
    return isCreator;
  };

  const canManageDrive = (drive) => {
    // If no createdBy info, nobody can manage
    if (!drive.createdBy) {
      console.log("❌ No creator info - no management access");
      return false;
    }

    // Check if user created the drive
    const isCreator = isDriveCreator(drive);

    // For PRs - also check department access
    if (user?.role === "placement_representative" || user?.role === "pr") {
      const userDept = normalizeDepartment(user.profile?.department);
      const creatorDept = normalizeDepartment(
        drive.createdBy?.profile?.department
      );

      console.log("=== MANAGE ACCESS CHECK ===");
      console.log("Drive:", drive.companyName);
      console.log("User:", user.email);
      console.log("User Dept (normalized):", userDept);
      console.log("Creator:", drive.createdBy.email);
      console.log("Creator Dept (normalized):", creatorDept);
      console.log("Is creator:", isCreator);

      // Allow if same department OR if user created the drive
      if (isCreator || (userDept && creatorDept && userDept === creatorDept)) {
        console.log(
          "✅ Management access granted - same department or creator"
        );
        return true;
      } else {
        console.log("❌ Different department and not creator - access denied");
        return false;
      }
    }

    // For POs - they can manage everything
    if (user?.role === "po" || user?.role === "placement_officer") {
      return true;
    }

    return isCreator;
  };

  const isViewOnlyPR = (drive) => {
    return (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      !canManageDrive(drive)
    );
  };

  // Function to check if applications are still open (for application deadline)
  const isApplicationDeadlinePassed = (drive) => {
    // If there's a deadline, use that; otherwise use drive date
    const checkDate = drive.deadline || drive.date;
    if (!checkDate) return false;

    const deadlineDateTime = new Date(checkDate);

    // If drive has a specific time, use it; otherwise assume end of day
    if (drive.time && drive.deadline) {
      const [hours, minutes] = drive.time.split(":");
      deadlineDateTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
    } else {
      // If no time specified, consider applications open until end of deadline day
      deadlineDateTime.setHours(23, 59, 59, 999);
    }

    const currentDateTime = new Date();
    return currentDateTime > deadlineDateTime;
  };

  // Function to check if drive has ended (for filtering purposes)
  const isDriveEnded = (drive) => {
    if (!drive.date) return false;

    const driveDate = new Date(drive.date);
    const currentDate = new Date();

    // If drive has time, use it for comparison
    if (drive.time) {
      const [hours, minutes] = drive.time.split(":").map(Number);
      driveDate.setHours(hours, minutes, 0, 0);
      return currentDate > driveDate;
    } else {
      // If no time specified, consider drive ended at end of day
      driveDate.setHours(23, 59, 59, 999);
      return currentDate > driveDate;
    }
  };

  const handleViewPlacedStudents = async (drive) => {
    try {
      const driveEnded = isDriveEnded(drive);
      
      // Only try to get students from selection rounds if drive has ended
      if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
        const token = localStorage.getItem("token");
        const response = await fetch(
          `http://localhost:5000/api/job-drives/${drive._id}/last-round-students`,
          {
            method: "GET",
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        if (response.ok) {
          const data = await response.json();
          if (data.students && data.students.length > 0) {
            // Create a drive object with the selection round students for modal display
            const driveWithRoundStudents = {
              ...drive,
              placedStudents: data.students, // Use students from final round
            };
            setSelectedDriveForView(driveWithRoundStudents);
            setShowPlacedStudentsViewModal(true);
            return;
          }
        }
      }

      // Always allow viewing manual placed students (regardless of drive end date)
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
        return;
      }

      // If no placed students found from either source
      toast.error("No placed students found for this drive");
    } catch (error) {
      console.error("Error fetching placed students:", error);
      // Fallback to showing manual placed students if API call fails
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
      } else {
        toast.error("Failed to fetch placed students");
      }
    }
  };

  useEffect(() => {
    // Wait for auth context to load before checking user
    if (user === null) {
      // Still loading auth state, don't redirect yet
      return;
    }

    // Allow both placement_representative and placement_officer
    if (
      !user ||
      (user.role !== "placement_representative" &&
        user.role !== "placement_officer" &&
        user.role !== "po")
    ) {
      navigate("/login");
      return;
    }
    fetchAllJobDrives();
  }, [user, navigate]);

  const fetchAllJobDrives = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem("token");
      const response = await axios.get("http://localhost:5000/api/job-drives", {
        headers: { Authorization: `Bearer ${token}` },
      });

      console.log("=== API RESPONSE DEBUG ===");
      console.log("Full response:", response.data);
      console.log("Job drives:", response.data.jobDrives);

      // Debug each drive's creator info
      response.data.jobDrives.forEach((drive, index) => {
        console.log(`Drive ${index + 1} (${drive.companyName}):`, {
          createdBy: drive.createdBy,
          createdById: drive.createdBy?._id,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      setDrives(response.data.jobDrives || []);
    } catch (error) {
      console.error("Error fetching job drives:", error);
      toast.error("Failed to fetch job drives");
    } finally {
      setLoading(false);
    }
  };

  // Add this useEffect to debug the data
  useEffect(() => {
    if (drives.length > 0) {
      console.log("=== DRIVES DEBUG ===");
      drives.forEach((drive, index) => {
        console.log(`Drive ${index + 1}:`, {
          company: drive.companyName,
          createdBy: drive.createdBy,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      console.log("Current user:", {
        role: user?.role,
        department: user?.profile?.department,
        profile: user?.profile,
      });
    }
  }, [drives, user]);

  const handleDeleteDrive = async (driveId) => {
    // Get drive details for the confirmation
    const drive = drives.find((d) => d._id === driveId);
    const driveName = drive
      ? `${drive.companyName} - ${drive.role}`
      : "this job drive";

    // Set up deletion target and show modal
    setDeleteTarget({
      id: driveId,
      name: driveName,
      drive: drive,
    });
    setShowDeleteModal(true);
  };

  const confirmDeleteDrive = async () => {
    if (!deleteTarget) return;

    // For PRs, validate reason
    if (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      (!deleteReason || deleteReason.trim() === "")
    ) {
      toast.error("Reason is required for deletion request");
      return;
    }

    try {
      const token = localStorage.getItem("token");

      // Use the new deletion request API
      await axios.post(
        "http://localhost:5000/api/deletion-requests/request",
        {
          jobDriveId: deleteTarget.id,
          reason: deleteReason || "Administrative deletion",
        },
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );

      if (user?.role === "po" || user?.role === "placement_officer") {
        toast.success("Job drive deleted successfully");
        setDrives(drives.filter((drive) => drive._id !== deleteTarget.id));
      } else {
        toast.success(
          "Deletion request submitted successfully. Awaiting PO approval."
        );
        // Don't remove from list as it's pending approval
      }

      // Close modal and reset state
      setShowDeleteModal(false);
      setDeleteTarget(null);
      setDeleteReason("");
    } catch (error) {
      console.error("Delete error:", error);
      if (error.response?.data?.message) {
        toast.error(error.response.data.message);
      } else {
        toast.error("Failed to process deletion request");
      }
    }
  };

  const cancelDelete = () => {
    setShowDeleteModal(false);
    setDeleteTarget(null);
    setDeleteReason("");
  };

  const handleEditDrive = (driveId) => {
    navigate(`/pr/edit-job/${driveId}?returnTo=/all-job-drives`);
  };

  const handleViewDetails = (drive) => {
    console.log("=== DRIVE DETAILS DEBUG ===");
    console.log("Full drive object:", JSON.stringify(drive, null, 2));
    console.log("Eligibility object:", drive.eligibility);
    console.log("Min CGPA field:", drive.eligibility?.minCGPA);
    console.log("CGPA field:", drive.eligibility?.cgpa);
    console.log("Test Details:", drive.testDetails);
    console.log("Interview Process:", drive.interviewProcess);
    console.log("Bond:", drive.bond);

    setSelectedDrive(drive);
    setShowModal(true);
  };

  const closeModal = () => {
    setShowModal(false);
    setSelectedDrive(null);
  };

  const getFilteredDrives = () => {
    console.log("=== ALL JOB DRIVES FILTERING ===");
    console.log("Total drives:", drives.length);
    console.log("Current filter:", filter);
    console.log("User role:", user?.role);

    return drives.filter((drive) => {
      const driveEnded = isDriveEnded(drive);
      console.log(
        `Drive ${drive.companyName}: ended=${driveEnded}, date=${drive.date}, time=${drive.time}`
      );

      if (filter === "upcoming") {
        return !driveEnded; // Not ended yet
      } else if (filter === "past") {
        return driveEnded; // Drive has ended
      }
      return true; // 'all' filter
    });
  };

  const handleEditStudent = (student, index) => {
    setEditingStudent(index);
    setEditStudentData({
      name: student.name,
      rollNumber: student.rollNumber,
      department: student.department || "",
      email: student.email,
      mobileNumber: student.mobileNumber || "",
    });
  };

  const handleSaveEdit = async (index) => {
    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/update-placed-student`,
        {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({
            index: index,
            studentData: editStudentData,
          }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student updated successfully!");
        setEditingStudent(null);

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to update student");
      }
    } catch (error) {
      console.error("Error updating student:", error);
      toast.error("Error updating student");
    }
  };

  const handleDeleteStudent = async (index) => {
    setDeleteStudentIndex(index);
    setShowDeleteStudentModal(true);
  };

  const confirmDeleteStudent = async () => {
    if (deleteStudentIndex === null) return;

    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/delete-placed-student`,
        {
          method: "DELETE",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({ index: deleteStudentIndex }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student deleted successfully!");

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to delete student");
      }
    } catch (error) {
      console.error("Error deleting student:", error);
      toast.error("Error deleting student");
    } finally {
      setShowDeleteStudentModal(false);
      setDeleteStudentIndex(null);
    }
  };

  const cancelDeleteStudent = () => {
    setShowDeleteStudentModal(false);
    setDeleteStudentIndex(null);
  };

  const downloadCSV = () => {
    if (!selectedDriveForView?.placedStudents?.length) {
      toast.error("No data to download");
      return;
    }

    const headers = [
      "S.No",
      "Name",
      "Roll Number",
      "Department",
      "Email",
      "Mobile",
      "Added On",
    ];
    const csvContent = [
      headers.join(","),
      ...selectedDriveForView.placedStudents.map((student, index) =>
        [
          index + 1,
          `"${student.name}"`,
          `"${student.rollNumber}"`,
          `"${student.department || "N/A"}"`,
          `"${student.email}"`,
          `"${student.mobileNumber || "N/A"}"`,
          `"${
            student.addedAt
              ? new Date(student.addedAt).toLocaleDateString()
              : "N/A"
          }"`,
        ].join(",")
      ),
    ].join("\n");

    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute(
      "download",
      `${selectedDriveForView.companyName}_placed_students.csv`
    );
    link.style.visibility = "hidden";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const handleManageRounds = (drive, roundIndex) => {
    // For same department PRs - full management access
    setSelectedJobForRounds(drive);
</original_code>```

```
import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../contexts/AuthContext";
import axios from "axios";
import toast from "react-hot-toast";
import PRJobCard from "./PRJobCard";
import RoundManagementModal from "./RoundManagementModal";
import {
  useJobDriveUpdates,
  useDeletionRequestUpdates,
  useApplicationUpdates,
  useSocketConnection,
  useModalUpdates,
  useRoundUpdates,
} from "../hooks/useSocket";

const normalizeDepartment = (dept) => {
  if (!dept) return null;
  return dept.toLowerCase().trim();
};

const AllJobDrives = () => {
  const { user } = useAuth();
  const navigate = useNavigate();
  const [drives, setDrives] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState("all");
  const [showModal, setShowModal] = useState(false);
  const [selectedDrive, setSelectedDrive] = useState(null);
  const [showPlacedStudentsViewModal, setShowPlacedStudentsViewModal] =
    useState(false);
  const [selectedDriveForView, setSelectedDriveForView] = useState(null);
  const [showRoundModal, setShowRoundModal] = useState(false);
  const [selectedJobForRounds, setSelectedJobForRounds] = useState(null);
  const [selectedRoundIndex, setSelectedRoundIndex] = useState(null);
  const [showRoundStudentsModal, setShowRoundStudentsModal] = useState(false);
  const [selectedRound, setSelectedRound] = useState(null);
  const [selectedJobForRoundView, setSelectedJobForRoundView] = useState(null);
  const [showManageRoundsModal, setShowManageRoundsModal] = useState(false);
  const [selectedDriveForRounds, setSelectedDriveForRounds] = useState(null);
  const [selectedRoundForManagement, setSelectedRoundForManagement] =
    useState(null);
  const [roundApplicants, setRoundApplicants] = useState([]);
  const [selectedStudentsForRound, setSelectedStudentsForRound] = useState([]);
  const [loadingApplicants, setLoadingApplicants] = useState(false);

  // Deletion confirmation modal states
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [deleteTarget, setDeleteTarget] = useState(null);
  const [deleteReason, setDeleteReason] = useState("");

  // Student deletion states
  const [showDeleteStudentModal, setShowDeleteStudentModal] = useState(false);
  const [deleteStudentIndex, setDeleteStudentIndex] = useState(null);

  // Helper function to count placed students (matches PO dashboard logic)
  const getPlacedStudentsCount = (drive) => {
    // Check if drive has ended first
    const driveEnded = isDriveEnded(drive);
    
    // Only count from selection rounds if drive has ended
    if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
      const lastRound = drive.selectionRounds[drive.selectionRounds.length - 1];
      const countFromRounds = lastRound.selectedStudents?.length || 0;
      if (countFromRounds > 0) {
        return countFromRounds;
      }
    }
    
    // Always allow manual placed students (regardless of drive end date)
    return drive.placedStudents?.length || 0;
  };

  // Socket connection and real-time updates
  useSocketConnection(user?.role);

  // Handle real-time job drive updates
  useJobDriveUpdates((data) => {
    const { action } = data;

    // Refetch all job drives to get the latest data
    if (
      action === "created" ||
      action === "updated" ||
      action === "deleted" ||
      action === "application_submitted"
    ) {
      fetchAllJobDrives();
    }
  });

  // Handle real-time deletion request updates
  useDeletionRequestUpdates((data) => {
    const { action } = data;

    // Refetch all job drives when deletion is approved
    if (action === "approved") {
      fetchAllJobDrives();
    }
  });

  // Handle real-time application updates
  useApplicationUpdates((data) => {
    // Refetch drives when application status changes
    fetchAllJobDrives();
  });

  // Handle real-time modal updates
  useModalUpdates(selectedDrive?._id, (updatedDrive, action) => {
    if (action === 'updated') {
      // Update the selected drive data in the modal
      setSelectedDrive(updatedDrive);
    }
  });

  // Handle real-time round updates
  useRoundUpdates((data) => {
    const { action, jobDrive } = data;
    
    // If modal is open for this drive, refresh the selected drive data
    if (selectedDrive && jobDrive && (jobDrive._id === selectedDrive._id || jobDrive.id === selectedDrive._id)) {
      setSelectedDrive(jobDrive);
    }
    
    // If round management modal is open, refresh that too
    if (selectedDriveForRounds && jobDrive && (jobDrive._id === selectedDriveForRounds._id || jobDrive.id === selectedDriveForRounds._id)) {
      setSelectedDriveForRounds(jobDrive);
    }
    
    // Refresh the drives list
    fetchAllJobDrives();
  });

  // Add these helper functions at the top of the component
  const isDriveCreator = (drive) => {
    const isCreator = drive.createdBy?._id === user?.id;
    console.log("=== CREATOR CHECK ===");
    console.log("Drive:", drive.companyName);
    console.log("Drive creator ID:", drive.createdBy?._id);
    console.log("Current user ID:", user?.id);
    console.log("Is creator:", isCreator);
    return isCreator;
  };

  const canManageDrive = (drive) => {
    // If no createdBy info, nobody can manage
    if (!drive.createdBy) {
      console.log("❌ No creator info - no management access");
      return false;
    }

    // Check if user created the drive
    const isCreator = isDriveCreator(drive);

    // For PRs - also check department access
    if (user?.role === "placement_representative" || user?.role === "pr") {
      const userDept = normalizeDepartment(user.profile?.department);
      const creatorDept = normalizeDepartment(
        drive.createdBy?.profile?.department
      );

      console.log("=== MANAGE ACCESS CHECK ===");
      console.log("Drive:", drive.companyName);
      console.log("User:", user.email);
      console.log("User Dept (normalized):", userDept);
      console.log("Creator:", drive.createdBy.email);
      console.log("Creator Dept (normalized):", creatorDept);
      console.log("Is creator:", isCreator);

      // Allow if same department OR if user created the drive
      if (isCreator || (userDept && creatorDept && userDept === creatorDept)) {
        console.log(
          "✅ Management access granted - same department or creator"
        );
        return true;
      } else {
        console.log("❌ Different department and not creator - access denied");
        return false;
      }
    }

    // For POs - they can manage everything
    if (user?.role === "po" || user?.role === "placement_officer") {
      return true;
    }

    return isCreator;
  };

  const isViewOnlyPR = (drive) => {
    return (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      !canManageDrive(drive)
    );
  };

  // Function to check if applications are still open (for application deadline)
  const isApplicationDeadlinePassed = (drive) => {
    // If there's a deadline, use that; otherwise use drive date
    const checkDate = drive.deadline || drive.date;
    if (!checkDate) return false;

    const deadlineDateTime = new Date(checkDate);

    // If drive has a specific time, use it; otherwise assume end of day
    if (drive.time && drive.deadline) {
      const [hours, minutes] = drive.time.split(":");
      deadlineDateTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
    } else {
      // If no time specified, consider applications open until end of deadline day
      deadlineDateTime.setHours(23, 59, 59, 999);
    }

    const currentDateTime = new Date();
    return currentDateTime > deadlineDateTime;
  };

  // Function to check if drive has ended (for filtering purposes)
  const isDriveEnded = (drive) => {
    if (!drive.date) return false;

    const driveDate = new Date(drive.date);
    const currentDate = new Date();

    // If drive has time, use it for comparison
    if (drive.time) {
      const [hours, minutes] = drive.time.split(":").map(Number);
      driveDate.setHours(hours, minutes, 0, 0);
      return currentDate > driveDate;
    } else {
      // If no time specified, consider drive ended at end of day
      driveDate.setHours(23, 59, 59, 999);
      return currentDate > driveDate;
    }
  };

  const handleViewPlacedStudents = async (drive) => {
    try {
      const driveEnded = isDriveEnded(drive);
      
      // Only try to get students from selection rounds if drive has ended
      if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
        const token = localStorage.getItem("token");
        const response = await fetch(
          `http://localhost:5000/api/job-drives/${drive._id}/last-round-students`,
          {
            method: "GET",
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        if (response.ok) {
          const data = await response.json();
          if (data.students && data.students.length > 0) {
            // Create a drive object with the selection round students for modal display
            const driveWithRoundStudents = {
              ...drive,
              placedStudents: data.students, // Use students from final round
            };
            setSelectedDriveForView(driveWithRoundStudents);
            setShowPlacedStudentsViewModal(true);
            return;
          }
        }
      }

      // Always allow viewing manual placed students (regardless of drive end date)
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
        return;
      }

      // If no placed students found from either source
      toast.error("No placed students found for this drive");
    } catch (error) {
      console.error("Error fetching placed students:", error);
      // Fallback to showing manual placed students if API call fails
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
      } else {
        toast.error("Failed to fetch placed students");
      }
    }
  };

  useEffect(() => {
    // Wait for auth context to load before checking user
    if (user === null) {
      // Still loading auth state, don't redirect yet
      return;
    }

    // Allow both placement_representative and placement_officer
    if (
      !user ||
      (user.role !== "placement_representative" &&
        user.role !== "placement_officer" &&
        user.role !== "po")
    ) {
      navigate("/login");
      return;
    }
    fetchAllJobDrives();
  }, [user, navigate]);

  const fetchAllJobDrives = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem("token");
      const response = await axios.get("http://localhost:5000/api/job-drives", {
        headers: { Authorization: `Bearer ${token}` },
      });

      console.log("=== API RESPONSE DEBUG ===");
      console.log("Full response:", response.data);
      console.log("Job drives:", response.data.jobDrives);

      // Debug each drive's creator info
      response.data.jobDrives.forEach((drive, index) => {
        console.log(`Drive ${index + 1} (${drive.companyName}):`, {
          createdBy: drive.createdBy,
          createdById: drive.createdBy?._id,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      setDrives(response.data.jobDrives || []);
    } catch (error) {
      console.error("Error fetching job drives:", error);
      toast.error("Failed to fetch job drives");
    } finally {
      setLoading(false);
    }
  };

  // Add this useEffect to debug the data
  useEffect(() => {
    if (drives.length > 0) {
      console.log("=== DRIVES DEBUG ===");
      drives.forEach((drive, index) => {
        console.log(`Drive ${index + 1}:`, {
          company: drive.companyName,
          createdBy: drive.createdBy,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      console.log("Current user:", {
        role: user?.role,
        department: user?.profile?.department,
        profile: user?.profile,
      });
    }
  }, [drives, user]);

  const handleDeleteDrive = async (driveId) => {
    // Get drive details for the confirmation
    const drive = drives.find((d) => d._id === driveId);
    const driveName = drive
      ? `${drive.companyName} - ${drive.role}`
      : "this job drive";

    // Set up deletion target and show modal
    setDeleteTarget({
      id: driveId,
      name: driveName,
      drive: drive,
    });
    setShowDeleteModal(true);
  };

  const confirmDeleteDrive = async () => {
    if (!deleteTarget) return;

    // For PRs, validate reason
    if (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      (!deleteReason || deleteReason.trim() === "")
    ) {
      toast.error("Reason is required for deletion request");
      return;
    }

    try {
      const token = localStorage.getItem("token");

      // Use the new deletion request API
      await axios.post(
        "http://localhost:5000/api/deletion-requests/request",
        {
          jobDriveId: deleteTarget.id,
          reason: deleteReason || "Administrative deletion",
        },
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );

      if (user?.role === "po" || user?.role === "placement_officer") {
        toast.success("Job drive deleted successfully");
        setDrives(drives.filter((drive) => drive._id !== deleteTarget.id));
      } else {
        toast.success(
          "Deletion request submitted successfully. Awaiting PO approval."
        );
        // Don't remove from list as it's pending approval
      }

      // Close modal and reset state
      setShowDeleteModal(false);
      setDeleteTarget(null);
      setDeleteReason("");
    } catch (error) {
      console.error("Delete error:", error);
      if (error.response?.data?.message) {
        toast.error(error.response.data.message);
      } else {
        toast.error("Failed to process deletion request");
      }
    }
  };

  const cancelDelete = () => {
    setShowDeleteModal(false);
    setDeleteTarget(null);
    setDeleteReason("");
  };

  const handleEditDrive = (driveId) => {
    navigate(`/pr/edit-job/${driveId}?returnTo=/all-job-drives`);
  };

  const handleViewDetails = (drive) => {
    console.log("=== DRIVE DETAILS DEBUG ===");
    console.log("Full drive object:", JSON.stringify(drive, null, 2));
    console.log("Eligibility object:", drive.eligibility);
    console.log("Min CGPA field:", drive.eligibility?.minCGPA);
    console.log("CGPA field:", drive.eligibility?.cgpa);
    console.log("Test Details:", drive.testDetails);
    console.log("Interview Process:", drive.interviewProcess);
    console.log("Bond:", drive.bond);

    setSelectedDrive(drive);
    setShowModal(true);
  };

  const closeModal = () => {
    setShowModal(false);
    setSelectedDrive(null);
  };

  const getFilteredDrives = () => {
    console.log("=== ALL JOB DRIVES FILTERING ===");
    console.log("Total drives:", drives.length);
    console.log("Current filter:", filter);
    console.log("User role:", user?.role);

    return drives.filter((drive) => {
      const driveEnded = isDriveEnded(drive);
      console.log(
        `Drive ${drive.companyName}: ended=${driveEnded}, date=${drive.date}, time=${drive.time}`
      );

      if (filter === "upcoming") {
        return !driveEnded; // Not ended yet
      } else if (filter === "past") {
        return driveEnded; // Drive has ended
      }
      return true; // 'all' filter
    });
  };

  const handleEditStudent = (student, index) => {
    setEditingStudent(index);
    setEditStudentData({
      name: student.name,
      rollNumber: student.rollNumber,
      department: student.department || "",
      email: student.email,
      mobileNumber: student.mobileNumber || "",
    });
  };

  const handleSaveEdit = async (index) => {
    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/update-placed-student`,
        {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({
            index: index,
            studentData: editStudentData,
          }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student updated successfully!");
        setEditingStudent(null);

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to update student");
      }
    } catch (error) {
      console.error("Error updating student:", error);
      toast.error("Error updating student");
    }
  };

  const handleDeleteStudent = async (index) => {
    setDeleteStudentIndex(index);
    setShowDeleteStudentModal(true);
  };

  const confirmDeleteStudent = async () => {
    if (deleteStudentIndex === null) return;

    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/delete-placed-student`,
        {
          method: "DELETE",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({ index: deleteStudentIndex }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student deleted successfully!");

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to delete student");
      }
    } catch (error) {
      console.error("Error deleting student:", error);
      toast.error("Error deleting student");
    } finally {
      setShowDeleteStudentModal(false);
      setDeleteStudentIndex(null);
    }
  };

  const cancelDeleteStudent = () => {
    setShowDeleteStudentModal(false);
    setDeleteStudentIndex(null);
  };

  const downloadCSV = () => {
    if (!selectedDriveForView?.placedStudents?.length) {
      toast.error("No data to download");
      return;
    }

    const headers = [
      "S.No",
      "Name",
      "Roll Number",
      "Department",
      "Email",
      "Mobile",
      "Added On",
    ];
    const csvContent = [
      headers.join(","),
      ...selectedDriveForView.placedStudents.map((student, index) =>
        [
          index + 1,
          `"${student.name}"`,
          `"${student.rollNumber}"`,
          `"${student.department || "N/A"}"`,
          `"${student.email}"`,
          `"${student.mobileNumber || "N/A"}"`,
          `"${
            student.addedAt
              ? new Date(student.addedAt).toLocaleDateString()
              : "N/A"
          }"`,
        ].join(",")
      ),
    ].join("\n");

    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute(
      "download",
      `${selectedDriveForView.companyName}_placed_students.csv`
    );
    link.style.visibility = "hidden";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const handleManageRounds = (drive, roundIndex) => {
    // For same department PRs - full management access
    setSelectedJobForRounds(drive);
</original_code>```

```
import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../contexts/AuthContext";
import axios from "axios";
import toast from "react-hot-toast";
import PRJobCard from "./PRJobCard";
import RoundManagementModal from "./RoundManagementModal";
import {
  useJobDriveUpdates,
  useDeletionRequestUpdates,
  useApplicationUpdates,
  useSocketConnection,
  useModalUpdates,
  useRoundUpdates,
} from "../hooks/useSocket";

const normalizeDepartment = (dept) => {
  if (!dept) return null;
  return dept.toLowerCase().trim();
};

const AllJobDrives = () => {
  const { user } = useAuth();
  const navigate = useNavigate();
  const [drives, setDrives] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState("all");
  const [showModal, setShowModal] = useState(false);
  const [selectedDrive, setSelectedDrive] = useState(null);
  const [showPlacedStudentsViewModal, setShowPlacedStudentsViewModal] =
    useState(false);
  const [selectedDriveForView, setSelectedDriveForView] = useState(null);
  const [showRoundModal, setShowRoundModal] = useState(false);
  const [selectedJobForRounds, setSelectedJobForRounds] = useState(null);
  const [selectedRoundIndex, setSelectedRoundIndex] = useState(null);
  const [showRoundStudentsModal, setShowRoundStudentsModal] = useState(false);
  const [selectedRound, setSelectedRound] = useState(null);
  const [selectedJobForRoundView, setSelectedJobForRoundView] = useState(null);
  const [showManageRoundsModal, setShowManageRoundsModal] = useState(false);
  const [selectedDriveForRounds, setSelectedDriveForRounds] = useState(null);
  const [selectedRoundForManagement, setSelectedRoundForManagement] =
    useState(null);
  const [roundApplicants, setRoundApplicants] = useState([]);
  const [selectedStudentsForRound, setSelectedStudentsForRound] = useState([]);
  const [loadingApplicants, setLoadingApplicants] = useState(false);

  // Deletion confirmation modal states
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [deleteTarget, setDeleteTarget] = useState(null);
  const [deleteReason, setDeleteReason] = useState("");

  // Student deletion states
  const [showDeleteStudentModal, setShowDeleteStudentModal] = useState(false);
  const [deleteStudentIndex, setDeleteStudentIndex] = useState(null);

  // Helper function to count placed students (matches PO dashboard logic)
  const getPlacedStudentsCount = (drive) => {
    // Check if drive has ended first
    const driveEnded = isDriveEnded(drive);
    
    // Only count from selection rounds if drive has ended
    if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
      const lastRound = drive.selectionRounds[drive.selectionRounds.length - 1];
      const countFromRounds = lastRound.selectedStudents?.length || 0;
      if (countFromRounds > 0) {
        return countFromRounds;
      }
    }
    
    // Always allow manual placed students (regardless of drive end date)
    return drive.placedStudents?.length || 0;
  };

  // Socket connection and real-time updates
  useSocketConnection(user?.role);

  // Handle real-time job drive updates
  useJobDriveUpdates((data) => {
    const { action } = data;

    // Refetch all job drives to get the latest data
    if (
      action === "created" ||
      action === "updated" ||
      action === "deleted" ||
      action === "application_submitted"
    ) {
      fetchAllJobDrives();
    }
  });

  // Handle real-time deletion request updates
  useDeletionRequestUpdates((data) => {
    const { action } = data;

    // Refetch all job drives when deletion is approved
    if (action === "approved") {
      fetchAllJobDrives();
    }
  });

  // Handle real-time application updates
  useApplicationUpdates((data) => {
    // Refetch drives when application status changes
    fetchAllJobDrives();
  });

  // Handle real-time modal updates
  useModalUpdates(selectedDrive?._id, (updatedDrive, action) => {
    if (action === 'updated') {
      // Update the selected drive data in the modal
      setSelectedDrive(updatedDrive);
    }
  });

  // Handle real-time round updates
  useRoundUpdates((data) => {
    const { action, jobDrive } = data;
    
    // If modal is open for this drive, refresh the selected drive data
    if (selectedDrive && jobDrive && (jobDrive._id === selectedDrive._id || jobDrive.id === selectedDrive._id)) {
      setSelectedDrive(jobDrive);
    }
    
    // If round management modal is open, refresh that too
    if (selectedDriveForRounds && jobDrive && (jobDrive._id === selectedDriveForRounds._id || jobDrive.id === selectedDriveForRounds._id)) {
      setSelectedDriveForRounds(jobDrive);
    }
    
    // Refresh the drives list
    fetchAllJobDrives();
  });

  // Add these helper functions at the top of the component
  const isDriveCreator = (drive) => {
    const isCreator = drive.createdBy?._id === user?.id;
    console.log("=== CREATOR CHECK ===");
    console.log("Drive:", drive.companyName);
    console.log("Drive creator ID:", drive.createdBy?._id);
    console.log("Current user ID:", user?.id);
    console.log("Is creator:", isCreator);
    return isCreator;
  };

  const canManageDrive = (drive) => {
    // If no createdBy info, nobody can manage
    if (!drive.createdBy) {
      console.log("❌ No creator info - no management access");
      return false;
    }

    // Check if user created the drive
    const isCreator = isDriveCreator(drive);

    // For PRs - also check department access
    if (user?.role === "placement_representative" || user?.role === "pr") {
      const userDept = normalizeDepartment(user.profile?.department);
      const creatorDept = normalizeDepartment(
        drive.createdBy?.profile?.department
      );

      console.log("=== MANAGE ACCESS CHECK ===");
      console.log("Drive:", drive.companyName);
      console.log("User:", user.email);
      console.log("User Dept (normalized):", userDept);
      console.log("Creator:", drive.createdBy.email);
      console.log("Creator Dept (normalized):", creatorDept);
      console.log("Is creator:", isCreator);

      // Allow if same department OR if user created the drive
      if (isCreator || (userDept && creatorDept && userDept === creatorDept)) {
        console.log(
          "✅ Management access granted - same department or creator"
        );
        return true;
      } else {
        console.log("❌ Different department and not creator - access denied");
        return false;
      }
    }

    // For POs - they can manage everything
    if (user?.role === "po" || user?.role === "placement_officer") {
      return true;
    }

    return isCreator;
  };

  const isViewOnlyPR = (drive) => {
    return (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      !canManageDrive(drive)
    );
  };

  // Function to check if applications are still open (for application deadline)
  const isApplicationDeadlinePassed = (drive) => {
    // If there's a deadline, use that; otherwise use drive date
    const checkDate = drive.deadline || drive.date;
    if (!checkDate) return false;

    const deadlineDateTime = new Date(checkDate);

    // If drive has a specific time, use it; otherwise assume end of day
    if (drive.time && drive.deadline) {
      const [hours, minutes] = drive.time.split(":");
      deadlineDateTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
    } else {
      // If no time specified, consider applications open until end of deadline day
      deadlineDateTime.setHours(23, 59, 59, 999);
    }

    const currentDateTime = new Date();
    return currentDateTime > deadlineDateTime;
  };

  // Function to check if drive has ended (for filtering purposes)
  const isDriveEnded = (drive) => {
    if (!drive.date) return false;

    const driveDate = new Date(drive.date);
    const currentDate = new Date();

    // If drive has time, use it for comparison
    if (drive.time) {
      const [hours, minutes] = drive.time.split(":").map(Number);
      driveDate.setHours(hours, minutes, 0, 0);
      return currentDate > driveDate;
    } else {
      // If no time specified, consider drive ended at end of day
      driveDate.setHours(23, 59, 59, 999);
      return currentDate > driveDate;
    }
  };

  const handleViewPlacedStudents = async (drive) => {
    try {
      const driveEnded = isDriveEnded(drive);
      
      // Only try to get students from selection rounds if drive has ended
      if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
        const token = localStorage.getItem("token");
        const response = await fetch(
          `http://localhost:5000/api/job-drives/${drive._id}/last-round-students`,
          {
            method: "GET",
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        if (response.ok) {
          const data = await response.json();
          if (data.students && data.students.length > 0) {
            // Create a drive object with the selection round students for modal display
            const driveWithRoundStudents = {
              ...drive,
              placedStudents: data.students, // Use students from final round
            };
            setSelectedDriveForView(driveWithRoundStudents);
            setShowPlacedStudentsViewModal(true);
            return;
          }
        }
      }

      // Always allow viewing manual placed students (regardless of drive end date)
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
        return;
      }

      // If no placed students found from either source
      toast.error("No placed students found for this drive");
    } catch (error) {
      console.error("Error fetching placed students:", error);
      // Fallback to showing manual placed students if API call fails
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
      } else {
        toast.error("Failed to fetch placed students");
      }
    }
  };

  useEffect(() => {
    // Wait for auth context to load before checking user
    if (user === null) {
      // Still loading auth state, don't redirect yet
      return;
    }

    // Allow both placement_representative and placement_officer
    if (
      !user ||
      (user.role !== "placement_representative" &&
        user.role !== "placement_officer" &&
        user.role !== "po")
    ) {
      navigate("/login");
      return;
    }
    fetchAllJobDrives();
  }, [user, navigate]);

  const fetchAllJobDrives = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem("token");
      const response = await axios.get("http://localhost:5000/api/job-drives", {
        headers: { Authorization: `Bearer ${token}` },
      });

      console.log("=== API RESPONSE DEBUG ===");
      console.log("Full response:", response.data);
      console.log("Job drives:", response.data.jobDrives);

      // Debug each drive's creator info
      response.data.jobDrives.forEach((drive, index) => {
        console.log(`Drive ${index + 1} (${drive.companyName}):`, {
          createdBy: drive.createdBy,
          createdById: drive.createdBy?._id,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      setDrives(response.data.jobDrives || []);
    } catch (error) {
      console.error("Error fetching job drives:", error);
      toast.error("Failed to fetch job drives");
    } finally {
      setLoading(false);
    }
  };

  // Add this useEffect to debug the data
  useEffect(() => {
    if (drives.length > 0) {
      console.log("=== DRIVES DEBUG ===");
      drives.forEach((drive, index) => {
        console.log(`Drive ${index + 1}:`, {
          company: drive.companyName,
          createdBy: drive.createdBy,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      console.log("Current user:", {
        role: user?.role,
        department: user?.profile?.department,
        profile: user?.profile,
      });
    }
  }, [drives, user]);

  const handleDeleteDrive = async (driveId) => {
    // Get drive details for the confirmation
    const drive = drives.find((d) => d._id === driveId);
    const driveName = drive
      ? `${drive.companyName} - ${drive.role}`
      : "this job drive";

    // Set up deletion target and show modal
    setDeleteTarget({
      id: driveId,
      name: driveName,
      drive: drive,
    });
    setShowDeleteModal(true);
  };

  const confirmDeleteDrive = async () => {
    if (!deleteTarget) return;

    // For PRs, validate reason
    if (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      (!deleteReason || deleteReason.trim() === "")
    ) {
      toast.error("Reason is required for deletion request");
      return;
    }

    try {
      const token = localStorage.getItem("token");

      // Use the new deletion request API
      await axios.post(
        "http://localhost:5000/api/deletion-requests/request",
        {
          jobDriveId: deleteTarget.id,
          reason: deleteReason || "Administrative deletion",
        },
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );

      if (user?.role === "po" || user?.role === "placement_officer") {
        toast.success("Job drive deleted successfully");
        setDrives(drives.filter((drive) => drive._id !== deleteTarget.id));
      } else {
        toast.success(
          "Deletion request submitted successfully. Awaiting PO approval."
        );
        // Don't remove from list as it's pending approval
      }

      // Close modal and reset state
      setShowDeleteModal(false);
      setDeleteTarget(null);
      setDeleteReason("");
    } catch (error) {
      console.error("Delete error:", error);
      if (error.response?.data?.message) {
        toast.error(error.response.data.message);
      } else {
        toast.error("Failed to process deletion request");
      }
    }
  };

  const cancelDelete = () => {
    setShowDeleteModal(false);
    setDeleteTarget(null);
    setDeleteReason("");
  };

  const handleEditDrive = (driveId) => {
    navigate(`/pr/edit-job/${driveId}?returnTo=/all-job-drives`);
  };

  const handleViewDetails = (drive) => {
    console.log("=== DRIVE DETAILS DEBUG ===");
    console.log("Full drive object:", JSON.stringify(drive, null, 2));
    console.log("Eligibility object:", drive.eligibility);
    console.log("Min CGPA field:", drive.eligibility?.minCGPA);
    console.log("CGPA field:", drive.eligibility?.cgpa);
    console.log("Test Details:", drive.testDetails);
    console.log("Interview Process:", drive.interviewProcess);
    console.log("Bond:", drive.bond);

    setSelectedDrive(drive);
    setShowModal(true);
  };

  const closeModal = () => {
    setShowModal(false);
    setSelectedDrive(null);
  };

  const getFilteredDrives = () => {
    console.log("=== ALL JOB DRIVES FILTERING ===");
    console.log("Total drives:", drives.length);
    console.log("Current filter:", filter);
    console.log("User role:", user?.role);

    return drives.filter((drive) => {
      const driveEnded = isDriveEnded(drive);
      console.log(
        `Drive ${drive.companyName}: ended=${driveEnded}, date=${drive.date}, time=${drive.time}`
      );

      if (filter === "upcoming") {
        return !driveEnded; // Not ended yet
      } else if (filter === "past") {
        return driveEnded; // Drive has ended
      }
      return true; // 'all' filter
    });
  };

  const handleEditStudent = (student, index) => {
    setEditingStudent(index);
    setEditStudentData({
      name: student.name,
      rollNumber: student.rollNumber,
      department: student.department || "",
      email: student.email,
      mobileNumber: student.mobileNumber || "",
    });
  };

  const handleSaveEdit = async (index) => {
    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/update-placed-student`,
        {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({
            index: index,
            studentData: editStudentData,
          }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student updated successfully!");
        setEditingStudent(null);

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to update student");
      }
    } catch (error) {
      console.error("Error updating student:", error);
      toast.error("Error updating student");
    }
  };

  const handleDeleteStudent = async (index) => {
    setDeleteStudentIndex(index);
    setShowDeleteStudentModal(true);
  };

  const confirmDeleteStudent = async () => {
    if (deleteStudentIndex === null) return;

    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/delete-placed-student`,
        {
          method: "DELETE",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({ index: deleteStudentIndex }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student deleted successfully!");

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to delete student");
      }
    } catch (error) {
      console.error("Error deleting student:", error);
      toast.error("Error deleting student");
    } finally {
      setShowDeleteStudentModal(false);
      setDeleteStudentIndex(null);
    }
  };

  const cancelDeleteStudent = () => {
    setShowDeleteStudentModal(false);
    setDeleteStudentIndex(null);
  };

  const downloadCSV = () => {
    if (!selectedDriveForView?.placedStudents?.length) {
      toast.error("No data to download");
      return;
    }

    const headers = [
      "S.No",
      "Name",
      "Roll Number",
      "Department",
      "Email",
      "Mobile",
      "Added On",
    ];
    const csvContent = [
      headers.join(","),
      ...selectedDriveForView.placedStudents.map((student, index) =>
        [
          index + 1,
          `"${student.name}"`,
          `"${student.rollNumber}"`,
          `"${student.department || "N/A"}"`,
          `"${student.email}"`,
          `"${student.mobileNumber || "N/A"}"`,
          `"${
            student.addedAt
              ? new Date(student.addedAt).toLocaleDateString()
              : "N/A"
          }"`,
        ].join(",")
      ),
    ].join("\n");

    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute(
      "download",
      `${selectedDriveForView.companyName}_placed_students.csv`
    );
    link.style.visibility = "hidden";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const handleManageRounds = (drive, roundIndex) => {
    // For same department PRs - full management access
    setSelectedJobForRounds(drive);
</original_code>```

```
import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../contexts/AuthContext";
import axios from "axios";
import toast from "react-hot-toast";
import PRJobCard from "./PRJobCard";
import RoundManagementModal from "./RoundManagementModal";
import {
  useJobDriveUpdates,
  useDeletionRequestUpdates,
  useApplicationUpdates,
  useSocketConnection,
  useModalUpdates,
  useRoundUpdates,
} from "../hooks/useSocket";

const normalizeDepartment = (dept) => {
  if (!dept) return null;
  return dept.toLowerCase().trim();
};

const AllJobDrives = () => {
  const { user } = useAuth();
  const navigate = useNavigate();
  const [drives, setDrives] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState("all");
  const [showModal, setShowModal] = useState(false);
  const [selectedDrive, setSelectedDrive] = useState(null);
  const [showPlacedStudentsViewModal, setShowPlacedStudentsViewModal] =
    useState(false);
  const [selectedDriveForView, setSelectedDriveForView] = useState(null);
  const [showRoundModal, setShowRoundModal] = useState(false);
  const [selectedJobForRounds, setSelectedJobForRounds] = useState(null);
  const [selectedRoundIndex, setSelectedRoundIndex] = useState(null);
  const [showRoundStudentsModal, setShowRoundStudentsModal] = useState(false);
  const [selectedRound, setSelectedRound] = useState(null);
  const [selectedJobForRoundView, setSelectedJobForRoundView] = useState(null);
  const [showManageRoundsModal, setShowManageRoundsModal] = useState(false);
  const [selectedDriveForRounds, setSelectedDriveForRounds] = useState(null);
  const [selectedRoundForManagement, setSelectedRoundForManagement] =
    useState(null);
  const [roundApplicants, setRoundApplicants] = useState([]);
  const [selectedStudentsForRound, setSelectedStudentsForRound] = useState([]);
  const [loadingApplicants, setLoadingApplicants] = useState(false);

  // Deletion confirmation modal states
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [deleteTarget, setDeleteTarget] = useState(null);
  const [deleteReason, setDeleteReason] = useState("");

  // Student deletion states
  const [showDeleteStudentModal, setShowDeleteStudentModal] = useState(false);
  const [deleteStudentIndex, setDeleteStudentIndex] = useState(null);

  // Helper function to count placed students (matches PO dashboard logic)
  const getPlacedStudentsCount = (drive) => {
    // Check if drive has ended first
    const driveEnded = isDriveEnded(drive);
    
    // Only count from selection rounds if drive has ended
    if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
      const lastRound = drive.selectionRounds[drive.selectionRounds.length - 1];
      const countFromRounds = lastRound.selectedStudents?.length || 0;
      if (countFromRounds > 0) {
        return countFromRounds;
      }
    }
    
    // Always allow manual placed students (regardless of drive end date)
    return drive.placedStudents?.length || 0;
  };

  // Socket connection and real-time updates
  useSocketConnection(user?.role);

  // Handle real-time job drive updates
  useJobDriveUpdates((data) => {
    const { action } = data;

    // Refetch all job drives to get the latest data
    if (
      action === "created" ||
      action === "updated" ||
      action === "deleted" ||
      action === "application_submitted"
    ) {
      fetchAllJobDrives();
    }
  });

  // Handle real-time deletion request updates
  useDeletionRequestUpdates((data) => {
    const { action } = data;

    // Refetch all job drives when deletion is approved
    if (action === "approved") {
      fetchAllJobDrives();
    }
  });

  // Handle real-time application updates
  useApplicationUpdates((data) => {
    // Refetch drives when application status changes
    fetchAllJobDrives();
  });

  // Handle real-time modal updates
  useModalUpdates(selectedDrive?._id, (updatedDrive, action) => {
    if (action === 'updated') {
      // Update the selected drive data in the modal
      setSelectedDrive(updatedDrive);
    }
  });

  // Handle real-time round updates
  useRoundUpdates((data) => {
    const { action, jobDrive } = data;
    
    // If modal is open for this drive, refresh the selected drive data
    if (selectedDrive && jobDrive && (jobDrive._id === selectedDrive._id || jobDrive.id === selectedDrive._id)) {
      setSelectedDrive(jobDrive);
    }
    
    // If round management modal is open, refresh that too
    if (selectedDriveForRounds && jobDrive && (jobDrive._id === selectedDriveForRounds._id || jobDrive.id === selectedDriveForRounds._id)) {
      setSelectedDriveForRounds(jobDrive);
    }
    
    // Refresh the drives list
    fetchAllJobDrives();
  });

  // Add these helper functions at the top of the component
  const isDriveCreator = (drive) => {
    const isCreator = drive.createdBy?._id === user?.id;
    console.log("=== CREATOR CHECK ===");
    console.log("Drive:", drive.companyName);
    console.log("Drive creator ID:", drive.createdBy?._id);
    console.log("Current user ID:", user?.id);
    console.log("Is creator:", isCreator);
    return isCreator;
  };

  const canManageDrive = (drive) => {
    // If no createdBy info, nobody can manage
    if (!drive.createdBy) {
      console.log("❌ No creator info - no management access");
      return false;
    }

    // Check if user created the drive
    const isCreator = isDriveCreator(drive);

    // For PRs - also check department access
    if (user?.role === "placement_representative" || user?.role === "pr") {
      const userDept = normalizeDepartment(user.profile?.department);
      const creatorDept = normalizeDepartment(
        drive.createdBy?.profile?.department
      );

      console.log("=== MANAGE ACCESS CHECK ===");
      console.log("Drive:", drive.companyName);
      console.log("User:", user.email);
      console.log("User Dept (normalized):", userDept);
      console.log("Creator:", drive.createdBy.email);
      console.log("Creator Dept (normalized):", creatorDept);
      console.log("Is creator:", isCreator);

      // Allow if same department OR if user created the drive
      if (isCreator || (userDept && creatorDept && userDept === creatorDept)) {
        console.log(
          "✅ Management access granted - same department or creator"
        );
        return true;
      } else {
        console.log("❌ Different department and not creator - access denied");
        return false;
      }
    }

    // For POs - they can manage everything
    if (user?.role === "po" || user?.role === "placement_officer") {
      return true;
    }

    return isCreator;
  };

  const isViewOnlyPR = (drive) => {
    return (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      !canManageDrive(drive)
    );
  };

  // Function to check if applications are still open (for application deadline)
  const isApplicationDeadlinePassed = (drive) => {
    // If there's a deadline, use that; otherwise use drive date
    const checkDate = drive.deadline || drive.date;
    if (!checkDate) return false;

    const deadlineDateTime = new Date(checkDate);

    // If drive has a specific time, use it; otherwise assume end of day
    if (drive.time && drive.deadline) {
      const [hours, minutes] = drive.time.split(":");
      deadlineDateTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
    } else {
      // If no time specified, consider applications open until end of deadline day
      deadlineDateTime.setHours(23, 59, 59, 999);
    }

    const currentDateTime = new Date();
    return currentDateTime > deadlineDateTime;
  };

  // Function to check if drive has ended (for filtering purposes)
  const isDriveEnded = (drive) => {
    if (!drive.date) return false;

    const driveDate = new Date(drive.date);
    const currentDate = new Date();

    // If drive has time, use it for comparison
    if (drive.time) {
      const [hours, minutes] = drive.time.split(":").map(Number);
      driveDate.setHours(hours, minutes, 0, 0);
      return currentDate > driveDate;
    } else {
      // If no time specified, consider drive ended at end of day
      driveDate.setHours(23, 59, 59, 999);
      return currentDate > driveDate;
    }
  };

  const handleViewPlacedStudents = async (drive) => {
    try {
      const driveEnded = isDriveEnded(drive);
      
      // Only try to get students from selection rounds if drive has ended
      if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
        const token = localStorage.getItem("token");
        const response = await fetch(
          `http://localhost:5000/api/job-drives/${drive._id}/last-round-students`,
          {
            method: "GET",
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        if (response.ok) {
          const data = await response.json();
          if (data.students && data.students.length > 0) {
            // Create a drive object with the selection round students for modal display
            const driveWithRoundStudents = {
              ...drive,
              placedStudents: data.students, // Use students from final round
            };
            setSelectedDriveForView(driveWithRoundStudents);
            setShowPlacedStudentsViewModal(true);
            return;
          }
        }
      }

      // Always allow viewing manual placed students (regardless of drive end date)
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
        return;
      }

      // If no placed students found from either source
      toast.error("No placed students found for this drive");
    } catch (error) {
      console.error("Error fetching placed students:", error);
      // Fallback to showing manual placed students if API call fails
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
      } else {
        toast.error("Failed to fetch placed students");
      }
    }
  };

  useEffect(() => {
    // Wait for auth context to load before checking user
    if (user === null) {
      // Still loading auth state, don't redirect yet
      return;
    }

    // Allow both placement_representative and placement_officer
    if (
      !user ||
      (user.role !== "placement_representative" &&
        user.role !== "placement_officer" &&
        user.role !== "po")
    ) {
      navigate("/login");
      return;
    }
    fetchAllJobDrives();
  }, [user, navigate]);

  const fetchAllJobDrives = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem("token");
      const response = await axios.get("http://localhost:5000/api/job-drives", {
        headers: { Authorization: `Bearer ${token}` },
      });

      console.log("=== API RESPONSE DEBUG ===");
      console.log("Full response:", response.data);
      console.log("Job drives:", response.data.jobDrives);

      // Debug each drive's creator info
      response.data.jobDrives.forEach((drive, index) => {
        console.log(`Drive ${index + 1} (${drive.companyName}):`, {
          createdBy: drive.createdBy,
          createdById: drive.createdBy?._id,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      setDrives(response.data.jobDrives || []);
    } catch (error) {
      console.error("Error fetching job drives:", error);
      toast.error("Failed to fetch job drives");
    } finally {
      setLoading(false);
    }
  };

  // Add this useEffect to debug the data
  useEffect(() => {
    if (drives.length > 0) {
      console.log("=== DRIVES DEBUG ===");
      drives.forEach((drive, index) => {
        console.log(`Drive ${index + 1}:`, {
          company: drive.companyName,
          createdBy: drive.createdBy,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      console.log("Current user:", {
        role: user?.role,
        department: user?.profile?.department,
        profile: user?.profile,
      });
    }
  }, [drives, user]);

  const handleDeleteDrive = async (driveId) => {
    // Get drive details for the confirmation
    const drive = drives.find((d) => d._id === driveId);
    const driveName = drive
      ? `${drive.companyName} - ${drive.role}`
      : "this job drive";

    // Set up deletion target and show modal
    setDeleteTarget({
      id: driveId,
      name: driveName,
      drive: drive,
    });
    setShowDeleteModal(true);
  };

  const confirmDeleteDrive = async () => {
    if (!deleteTarget) return;

    // For PRs, validate reason
    if (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      (!deleteReason || deleteReason.trim() === "")
    ) {
      toast.error("Reason is required for deletion request");
      return;
    }

    try {
      const token = localStorage.getItem("token");

      // Use the new deletion request API
      await axios.post(
        "http://localhost:5000/api/deletion-requests/request",
        {
          jobDriveId: deleteTarget.id,
          reason: deleteReason || "Administrative deletion",
        },
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );

      if (user?.role === "po" || user?.role === "placement_officer") {
        toast.success("Job drive deleted successfully");
        setDrives(drives.filter((drive) => drive._id !== deleteTarget.id));
      } else {
        toast.success(
          "Deletion request submitted successfully. Awaiting PO approval."
        );
        // Don't remove from list as it's pending approval
      }

      // Close modal and reset state
      setShowDeleteModal(false);
      setDeleteTarget(null);
      setDeleteReason("");
    } catch (error) {
      console.error("Delete error:", error);
      if (error.response?.data?.message) {
        toast.error(error.response.data.message);
      } else {
        toast.error("Failed to process deletion request");
      }
    }
  };

  const cancelDelete = () => {
    setShowDeleteModal(false);
    setDeleteTarget(null);
    setDeleteReason("");
  };

  const handleEditDrive = (driveId) => {
    navigate(`/pr/edit-job/${driveId}?returnTo=/all-job-drives`);
  };

  const handleViewDetails = (drive) => {
    console.log("=== DRIVE DETAILS DEBUG ===");
    console.log("Full drive object:", JSON.stringify(drive, null, 2));
    console.log("Eligibility object:", drive.eligibility);
    console.log("Min CGPA field:", drive.eligibility?.minCGPA);
    console.log("CGPA field:", drive.eligibility?.cgpa);
    console.log("Test Details:", drive.testDetails);
    console.log("Interview Process:", drive.interviewProcess);
    console.log("Bond:", drive.bond);

    setSelectedDrive(drive);
    setShowModal(true);
  };

  const closeModal = () => {
    setShowModal(false);
    setSelectedDrive(null);
  };

  const getFilteredDrives = () => {
    console.log("=== ALL JOB DRIVES FILTERING ===");
    console.log("Total drives:", drives.length);
    console.log("Current filter:", filter);
    console.log("User role:", user?.role);

    return drives.filter((drive) => {
      const driveEnded = isDriveEnded(drive);
      console.log(
        `Drive ${drive.companyName}: ended=${driveEnded}, date=${drive.date}, time=${drive.time}`
      );

      if (filter === "upcoming") {
        return !driveEnded; // Not ended yet
      } else if (filter === "past") {
        return driveEnded; // Drive has ended
      }
      return true; // 'all' filter
    });
  };

  const handleEditStudent = (student, index) => {
    setEditingStudent(index);
    setEditStudentData({
      name: student.name,
      rollNumber: student.rollNumber,
      department: student.department || "",
      email: student.email,
      mobileNumber: student.mobileNumber || "",
    });
  };

  const handleSaveEdit = async (index) => {
    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/update-placed-student`,
        {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({
            index: index,
            studentData: editStudentData,
          }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student updated successfully!");
        setEditingStudent(null);

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to update student");
      }
    } catch (error) {
      console.error("Error updating student:", error);
      toast.error("Error updating student");
    }
  };

  const handleDeleteStudent = async (index) => {
    setDeleteStudentIndex(index);
    setShowDeleteStudentModal(true);
  };

  const confirmDeleteStudent = async () => {
    if (deleteStudentIndex === null) return;

    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/delete-placed-student`,
        {
          method: "DELETE",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({ index: deleteStudentIndex }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student deleted successfully!");

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to delete student");
      }
    } catch (error) {
      console.error("Error deleting student:", error);
      toast.error("Error deleting student");
    } finally {
      setShowDeleteStudentModal(false);
      setDeleteStudentIndex(null);
    }
  };

  const cancelDeleteStudent = () => {
    setShowDeleteStudentModal(false);
    setDeleteStudentIndex(null);
  };

  const downloadCSV = () => {
    if (!selectedDriveForView?.placedStudents?.length) {
      toast.error("No data to download");
      return;
    }

    const headers = [
      "S.No",
      "Name",
      "Roll Number",
      "Department",
      "Email",
      "Mobile",
      "Added On",
    ];
    const csvContent = [
      headers.join(","),
      ...selectedDriveForView.placedStudents.map((student, index) =>
        [
          index + 1,
          `"${student.name}"`,
          `"${student.rollNumber}"`,
          `"${student.department || "N/A"}"`,
          `"${student.email}"`,
          `"${student.mobileNumber || "N/A"}"`,
          `"${
            student.addedAt
              ? new Date(student.addedAt).toLocaleDateString()
              : "N/A"
          }"`,
        ].join(",")
      ),
    ].join("\n");

    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute(
      "download",
      `${selectedDriveForView.companyName}_placed_students.csv`
    );
    link.style.visibility = "hidden";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const handleManageRounds = (drive, roundIndex) => {
    // For same department PRs - full management access
    setSelectedJobForRounds(drive);
</original_code>```

```
import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../contexts/AuthContext";
import axios from "axios";
import toast from "react-hot-toast";
import PRJobCard from "./PRJobCard";
import RoundManagementModal from "./RoundManagementModal";
import {
  useJobDriveUpdates,
  useDeletionRequestUpdates,
  useApplicationUpdates,
  useSocketConnection,
  useModalUpdates,
  useRoundUpdates,
} from "../hooks/useSocket";

const normalizeDepartment = (dept) => {
  if (!dept) return null;
  return dept.toLowerCase().trim();
};

const AllJobDrives = () => {
  const { user } = useAuth();
  const navigate = useNavigate();
  const [drives, setDrives] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState("all");
  const [showModal, setShowModal] = useState(false);
  const [selectedDrive, setSelectedDrive] = useState(null);
  const [showPlacedStudentsViewModal, setShowPlacedStudentsViewModal] =
    useState(false);
  const [selectedDriveForView, setSelectedDriveForView] = useState(null);
  const [showRoundModal, setShowRoundModal] = useState(false);
  const [selectedJobForRounds, setSelectedJobForRounds] = useState(null);
  const [selectedRoundIndex, setSelectedRoundIndex] = useState(null);
  const [showRoundStudentsModal, setShowRoundStudentsModal] = useState(false);
  const [selectedRound, setSelectedRound] = useState(null);
  const [selectedJobForRoundView, setSelectedJobForRoundView] = useState(null);
  const [showManageRoundsModal, setShowManageRoundsModal] = useState(false);
  const [selectedDriveForRounds, setSelectedDriveForRounds] = useState(null);
  const [selectedRoundForManagement, setSelectedRoundForManagement] =
    useState(null);
  const [roundApplicants, setRoundApplicants] = useState([]);
  const [selectedStudentsForRound, setSelectedStudentsForRound] = useState([]);
  const [loadingApplicants, setLoadingApplicants] = useState(false);

  // Deletion confirmation modal states
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [deleteTarget, setDeleteTarget] = useState(null);
  const [deleteReason, setDeleteReason] = useState("");

  // Student deletion states
  const [showDeleteStudentModal, setShowDeleteStudentModal] = useState(false);
  const [deleteStudentIndex, setDeleteStudentIndex] = useState(null);

  // Helper function to count placed students (matches PO dashboard logic)
  const getPlacedStudentsCount = (drive) => {
    // Check if drive has ended first
    const driveEnded = isDriveEnded(drive);
    
    // Only count from selection rounds if drive has ended
    if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
      const lastRound = drive.selectionRounds[drive.selectionRounds.length - 1];
      const countFromRounds = lastRound.selectedStudents?.length || 0;
      if (countFromRounds > 0) {
        return countFromRounds;
      }
    }
    
    // Always allow manual placed students (regardless of drive end date)
    return drive.placedStudents?.length || 0;
  };

  // Socket connection and real-time updates
  useSocketConnection(user?.role);

  // Handle real-time job drive updates
  useJobDriveUpdates((data) => {
    const { action } = data;

    // Refetch all job drives to get the latest data
    if (
      action === "created" ||
      action === "updated" ||
      action === "deleted" ||
      action === "application_submitted"
    ) {
      fetchAllJobDrives();
    }
  });

  // Handle real-time deletion request updates
  useDeletionRequestUpdates((data) => {
    const { action } = data;

    // Refetch all job drives when deletion is approved
    if (action === "approved") {
      fetchAllJobDrives();
    }
  });

  // Handle real-time application updates
  useApplicationUpdates((data) => {
    // Refetch drives when application status changes
    fetchAllJobDrives();
  });

  // Handle real-time modal updates
  useModalUpdates(selectedDrive?._id, (updatedDrive, action) => {
    if (action === 'updated') {
      // Update the selected drive data in the modal
      setSelectedDrive(updatedDrive);
    }
  });

  // Handle real-time round updates
  useRoundUpdates((data) => {
    const { action, jobDrive } = data;
    
    // If modal is open for this drive, refresh the selected drive data
    if (selectedDrive && jobDrive && (jobDrive._id === selectedDrive._id || jobDrive.id === selectedDrive._id)) {
      setSelectedDrive(jobDrive);
    }
    
    // If round management modal is open, refresh that too
    if (selectedDriveForRounds && jobDrive && (jobDrive._id === selectedDriveForRounds._id || jobDrive.id === selectedDriveForRounds._id)) {
      setSelectedDriveForRounds(jobDrive);
    }
    
    // Refresh the drives list
    fetchAllJobDrives();
  });

  // Add these helper functions at the top of the component
  const isDriveCreator = (drive) => {
    const isCreator = drive.createdBy?._id === user?.id;
    console.log("=== CREATOR CHECK ===");
    console.log("Drive:", drive.companyName);
    console.log("Drive creator ID:", drive.createdBy?._id);
    console.log("Current user ID:", user?.id);
    console.log("Is creator:", isCreator);
    return isCreator;
  };

  const canManageDrive = (drive) => {
    // If no createdBy info, nobody can manage
    if (!drive.createdBy) {
      console.log("❌ No creator info - no management access");
      return false;
    }

    // Check if user created the drive
    const isCreator = isDriveCreator(drive);

    // For PRs - also check department access
    if (user?.role === "placement_representative" || user?.role === "pr") {
      const userDept = normalizeDepartment(user.profile?.department);
      const creatorDept = normalizeDepartment(
        drive.createdBy?.profile?.department
      );

      console.log("=== MANAGE ACCESS CHECK ===");
      console.log("Drive:", drive.companyName);
      console.log("User:", user.email);
      console.log("User Dept (normalized):", userDept);
      console.log("Creator:", drive.createdBy.email);
      console.log("Creator Dept (normalized):", creatorDept);
      console.log("Is creator:", isCreator);

      // Allow if same department OR if user created the drive
      if (isCreator || (userDept && creatorDept && userDept === creatorDept)) {
        console.log(
          "✅ Management access granted - same department or creator"
        );
        return true;
      } else {
        console.log("❌ Different department and not creator - access denied");
        return false;
      }
    }

    // For POs - they can manage everything
    if (user?.role === "po" || user?.role === "placement_officer") {
      return true;
    }

    return isCreator;
  };

  const isViewOnlyPR = (drive) => {
    return (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      !canManageDrive(drive)
    );
  };

  // Function to check if applications are still open (for application deadline)
  const isApplicationDeadlinePassed = (drive) => {
    // If there's a deadline, use that; otherwise use drive date
    const checkDate = drive.deadline || drive.date;
    if (!checkDate) return false;

    const deadlineDateTime = new Date(checkDate);

    // If drive has a specific time, use it; otherwise assume end of day
    if (drive.time && drive.deadline) {
      const [hours, minutes] = drive.time.split(":");
      deadlineDateTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
    } else {
      // If no time specified, consider applications open until end of deadline day
      deadlineDateTime.setHours(23, 59, 59, 999);
    }

    const currentDateTime = new Date();
    return currentDateTime > deadlineDateTime;
  };

  // Function to check if drive has ended (for filtering purposes)
  const isDriveEnded = (drive) => {
    if (!drive.date) return false;

    const driveDate = new Date(drive.date);
    const currentDate = new Date();

    // If drive has time, use it for comparison
    if (drive.time) {
      const [hours, minutes] = drive.time.split(":").map(Number);
      driveDate.setHours(hours, minutes, 0, 0);
      return currentDate > driveDate;
    } else {
      // If no time specified, consider drive ended at end of day
      driveDate.setHours(23, 59, 59, 999);
      return currentDate > driveDate;
    }
  };

  const handleViewPlacedStudents = async (drive) => {
    try {
      const driveEnded = isDriveEnded(drive);
      
      // Only try to get students from selection rounds if drive has ended
      if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
        const token = localStorage.getItem("token");
        const response = await fetch(
          `http://localhost:5000/api/job-drives/${drive._id}/last-round-students`,
          {
            method: "GET",
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        if (response.ok) {
          const data = await response.json();
          if (data.students && data.students.length > 0) {
            // Create a drive object with the selection round students for modal display
            const driveWithRoundStudents = {
              ...drive,
              placedStudents: data.students, // Use students from final round
            };
            setSelectedDriveForView(driveWithRoundStudents);
            setShowPlacedStudentsViewModal(true);
            return;
          }
        }
      }

      // Always allow viewing manual placed students (regardless of drive end date)
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
        return;
      }

      // If no placed students found from either source
      toast.error("No placed students found for this drive");
    } catch (error) {
      console.error("Error fetching placed students:", error);
      // Fallback to showing manual placed students if API call fails
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
      } else {
        toast.error("Failed to fetch placed students");
      }
    }
  };

  useEffect(() => {
    // Wait for auth context to load before checking user
    if (user === null) {
      // Still loading auth state, don't redirect yet
      return;
    }

    // Allow both placement_representative and placement_officer
    if (
      !user ||
      (user.role !== "placement_representative" &&
        user.role !== "placement_officer" &&
        user.role !== "po")
    ) {
      navigate("/login");
      return;
    }
    fetchAllJobDrives();
  }, [user, navigate]);

  const fetchAllJobDrives = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem("token");
      const response = await axios.get("http://localhost:5000/api/job-drives", {
        headers: { Authorization: `Bearer ${token}` },
      });

      console.log("=== API RESPONSE DEBUG ===");
      console.log("Full response:", response.data);
      console.log("Job drives:", response.data.jobDrives);

      // Debug each drive's creator info
      response.data.jobDrives.forEach((drive, index) => {
        console.log(`Drive ${index + 1} (${drive.companyName}):`, {
          createdBy: drive.createdBy,
          createdById: drive.createdBy?._id,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      setDrives(response.data.jobDrives || []);
    } catch (error) {
      console.error("Error fetching job drives:", error);
      toast.error("Failed to fetch job drives");
    } finally {
      setLoading(false);
    }
  };

  // Add this useEffect to debug the data
  useEffect(() => {
    if (drives.length > 0) {
      console.log("=== DRIVES DEBUG ===");
      drives.forEach((drive, index) => {
        console.log(`Drive ${index + 1}:`, {
          company: drive.companyName,
          createdBy: drive.createdBy,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      console.log("Current user:", {
        role: user?.role,
        department: user?.profile?.department,
        profile: user?.profile,
      });
    }
  }, [drives, user]);

  const handleDeleteDrive = async (driveId) => {
    // Get drive details for the confirmation
    const drive = drives.find((d) => d._id === driveId);
    const driveName = drive
      ? `${drive.companyName} - ${drive.role}`
      : "this job drive";

    // Set up deletion target and show modal
    setDeleteTarget({
      id: driveId,
      name: driveName,
      drive: drive,
    });
    setShowDeleteModal(true);
  };

  const confirmDeleteDrive = async () => {
    if (!deleteTarget) return;

    // For PRs, validate reason
    if (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      (!deleteReason || deleteReason.trim() === "")
    ) {
      toast.error("Reason is required for deletion request");
      return;
    }

    try {
      const token = localStorage.getItem("token");

      // Use the new deletion request API
      await axios.post(
        "http://localhost:5000/api/deletion-requests/request",
        {
          jobDriveId: deleteTarget.id,
          reason: deleteReason || "Administrative deletion",
        },
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );

      if (user?.role === "po" || user?.role === "placement_officer") {
        toast.success("Job drive deleted successfully");
        setDrives(drives.filter((drive) => drive._id !== deleteTarget.id));
      } else {
        toast.success(
          "Deletion request submitted successfully. Awaiting PO approval."
        );
        // Don't remove from list as it's pending approval
      }

      // Close modal and reset state
      setShowDeleteModal(false);
      setDeleteTarget(null);
      setDeleteReason("");
    } catch (error) {
      console.error("Delete error:", error);
      if (error.response?.data?.message) {
        toast.error(error.response.data.message);
      } else {
        toast.error("Failed to process deletion request");
      }
    }
  };

  const cancelDelete = () => {
    setShowDeleteModal(false);
    setDeleteTarget(null);
    setDeleteReason("");
  };

  const handleEditDrive = (driveId) => {
    navigate(`/pr/edit-job/${driveId}?returnTo=/all-job-drives`);
  };

  const handleViewDetails = (drive) => {
    console.log("=== DRIVE DETAILS DEBUG ===");
    console.log("Full drive object:", JSON.stringify(drive, null, 2));
    console.log("Eligibility object:", drive.eligibility);
    console.log("Min CGPA field:", drive.eligibility?.minCGPA);
    console.log("CGPA field:", drive.eligibility?.cgpa);
    console.log("Test Details:", drive.testDetails);
    console.log("Interview Process:", drive.interviewProcess);
    console.log("Bond:", drive.bond);

    setSelectedDrive(drive);
    setShowModal(true);
  };

  const closeModal = () => {
    setShowModal(false);
    setSelectedDrive(null);
  };

  const getFilteredDrives = () => {
    console.log("=== ALL JOB DRIVES FILTERING ===");
    console.log("Total drives:", drives.length);
    console.log("Current filter:", filter);
    console.log("User role:", user?.role);

    return drives.filter((drive) => {
      const driveEnded = isDriveEnded(drive);
      console.log(
        `Drive ${drive.companyName}: ended=${driveEnded}, date=${drive.date}, time=${drive.time}`
      );

      if (filter === "upcoming") {
        return !driveEnded; // Not ended yet
      } else if (filter === "past") {
        return driveEnded; // Drive has ended
      }
      return true; // 'all' filter
    });
  };

  const handleEditStudent = (student, index) => {
    setEditingStudent(index);
    setEditStudentData({
      name: student.name,
      rollNumber: student.rollNumber,
      department: student.department || "",
      email: student.email,
      mobileNumber: student.mobileNumber || "",
    });
  };

  const handleSaveEdit = async (index) => {
    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/update-placed-student`,
        {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({
            index: index,
            studentData: editStudentData,
          }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student updated successfully!");
        setEditingStudent(null);

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to update student");
      }
    } catch (error) {
      console.error("Error updating student:", error);
      toast.error("Error updating student");
    }
  };

  const handleDeleteStudent = async (index) => {
    setDeleteStudentIndex(index);
    setShowDeleteStudentModal(true);
  };

  const confirmDeleteStudent = async () => {
    if (deleteStudentIndex === null) return;

    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/delete-placed-student`,
        {
          method: "DELETE",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({ index: deleteStudentIndex }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student deleted successfully!");

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to delete student");
      }
    } catch (error) {
      console.error("Error deleting student:", error);
      toast.error("Error deleting student");
    } finally {
      setShowDeleteStudentModal(false);
      setDeleteStudentIndex(null);
    }
  };

  const cancelDeleteStudent = () => {
    setShowDeleteStudentModal(false);
    setDeleteStudentIndex(null);
  };

  const downloadCSV = () => {
    if (!selectedDriveForView?.placedStudents?.length) {
      toast.error("No data to download");
      return;
    }

    const headers = [
      "S.No",
      "Name",
      "Roll Number",
      "Department",
      "Email",
      "Mobile",
      "Added On",
    ];
    const csvContent = [
      headers.join(","),
      ...selectedDriveForView.placedStudents.map((student, index) =>
        [
          index + 1,
          `"${student.name}"`,
          `"${student.rollNumber}"`,
          `"${student.department || "N/A"}"`,
          `"${student.email}"`,
          `"${student.mobileNumber || "N/A"}"`,
          `"${
            student.addedAt
              ? new Date(student.addedAt).toLocaleDateString()
              : "N/A"
          }"`,
        ].join(",")
      ),
    ].join("\n");

    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute(
      "download",
      `${selectedDriveForView.companyName}_placed_students.csv`
    );
    link.style.visibility = "hidden";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const handleManageRounds = (drive, roundIndex) => {
    // For same department PRs - full management access
    setSelectedJobForRounds(drive);
</original_code>```

```
import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../contexts/AuthContext";
import axios from "axios";
import toast from "react-hot-toast";
import PRJobCard from "./PRJobCard";
import RoundManagementModal from "./RoundManagementModal";
import {
  useJobDriveUpdates,
  useDeletionRequestUpdates,
  useApplicationUpdates,
  useSocketConnection,
  useModalUpdates,
  useRoundUpdates,
} from "../hooks/useSocket";

const normalizeDepartment = (dept) => {
  if (!dept) return null;
  return dept.toLowerCase().trim();
};

const AllJobDrives = () => {
  const { user } = useAuth();
  const navigate = useNavigate();
  const [drives, setDrives] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState("all");
  const [showModal, setShowModal] = useState(false);
  const [selectedDrive, setSelectedDrive] = useState(null);
  const [showPlacedStudentsViewModal, setShowPlacedStudentsViewModal] =
    useState(false);
  const [selectedDriveForView, setSelectedDriveForView] = useState(null);
  const [showRoundModal, setShowRoundModal] = useState(false);
  const [selectedJobForRounds, setSelectedJobForRounds] = useState(null);
  const [selectedRoundIndex, setSelectedRoundIndex] = useState(null);
  const [showRoundStudentsModal, setShowRoundStudentsModal] = useState(false);
  const [selectedRound, setSelectedRound] = useState(null);
  const [selectedJobForRoundView, setSelectedJobForRoundView] = useState(null);
  const [showManageRoundsModal, setShowManageRoundsModal] = useState(false);
  const [selectedDriveForRounds, setSelectedDriveForRounds] = useState(null);
  const [selectedRoundForManagement, setSelectedRoundForManagement] =
    useState(null);
  const [roundApplicants, setRoundApplicants] = useState([]);
  const [selectedStudentsForRound, setSelectedStudentsForRound] = useState([]);
  const [loadingApplicants, setLoadingApplicants] = useState(false);

  // Deletion confirmation modal states
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [deleteTarget, setDeleteTarget] = useState(null);
  const [deleteReason, setDeleteReason] = useState("");

  // Student deletion states
  const [showDeleteStudentModal, setShowDeleteStudentModal] = useState(false);
  const [deleteStudentIndex, setDeleteStudentIndex] = useState(null);

  // Helper function to count placed students (matches PO dashboard logic)
  const getPlacedStudentsCount = (drive) => {
    // Check if drive has ended first
    const driveEnded = isDriveEnded(drive);
    
    // Only count from selection rounds if drive has ended
    if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
      const lastRound = drive.selectionRounds[drive.selectionRounds.length - 1];
      const countFromRounds = lastRound.selectedStudents?.length || 0;
      if (countFromRounds > 0) {
        return countFromRounds;
      }
    }
    
    // Always allow manual placed students (regardless of drive end date)
    return drive.placedStudents?.length || 0;
  };

  // Socket connection and real-time updates
  useSocketConnection(user?.role);

  // Handle real-time job drive updates
  useJobDriveUpdates((data) => {
    const { action } = data;

    // Refetch all job drives to get the latest data
    if (
      action === "created" ||
      action === "updated" ||
      action === "deleted" ||
      action === "application_submitted"
    ) {
      fetchAllJobDrives();
    }
  });

  // Handle real-time deletion request updates
  useDeletionRequestUpdates((data) => {
    const { action } = data;

    // Refetch all job drives when deletion is approved
    if (action === "approved") {
      fetchAllJobDrives();
    }
  });

  // Handle real-time application updates
  useApplicationUpdates((data) => {
    // Refetch drives when application status changes
    fetchAllJobDrives();
  });

  // Handle real-time modal updates
  useModalUpdates(selectedDrive?._id, (updatedDrive, action) => {
    if (action === 'updated') {
      // Update the selected drive data in the modal
      setSelectedDrive(updatedDrive);
    }
  });

  // Handle real-time round updates
  useRoundUpdates((data) => {
    const { action, jobDrive } = data;
    
    // If modal is open for this drive, refresh the selected drive data
    if (selectedDrive && jobDrive && (jobDrive._id === selectedDrive._id || jobDrive.id === selectedDrive._id)) {
      setSelectedDrive(jobDrive);
    }
    
    // If round management modal is open, refresh that too
    if (selectedDriveForRounds && jobDrive && (jobDrive._id === selectedDriveForRounds._id || jobDrive.id === selectedDriveForRounds._id)) {
      setSelectedDriveForRounds(jobDrive);
    }
    
    // Refresh the drives list
    fetchAllJobDrives();
  });

  // Add these helper functions at the top of the component
  const isDriveCreator = (drive) => {
    const isCreator = drive.createdBy?._id === user?.id;
    console.log("=== CREATOR CHECK ===");
    console.log("Drive:", drive.companyName);
    console.log("Drive creator ID:", drive.createdBy?._id);
    console.log("Current user ID:", user?.id);
    console.log("Is creator:", isCreator);
    return isCreator;
  };

  const canManageDrive = (drive) => {
    // If no createdBy info, nobody can manage
    if (!drive.createdBy) {
      console.log("❌ No creator info - no management access");
      return false;
    }

    // Check if user created the drive
    const isCreator = isDriveCreator(drive);

    // For PRs - also check department access
    if (user?.role === "placement_representative" || user?.role === "pr") {
      const userDept = normalizeDepartment(user.profile?.department);
      const creatorDept = normalizeDepartment(
        drive.createdBy?.profile?.department
      );

      console.log("=== MANAGE ACCESS CHECK ===");
      console.log("Drive:", drive.companyName);
      console.log("User:", user.email);
      console.log("User Dept (normalized):", userDept);
      console.log("Creator:", drive.createdBy.email);
      console.log("Creator Dept (normalized):", creatorDept);
      console.log("Is creator:", isCreator);

      // Allow if same department OR if user created the drive
      if (isCreator || (userDept && creatorDept && userDept === creatorDept)) {
        console.log(
          "✅ Management access granted - same department or creator"
        );
        return true;
      } else {
        console.log("❌ Different department and not creator - access denied");
        return false;
      }
    }

    // For POs - they can manage everything
    if (user?.role === "po" || user?.role === "placement_officer") {
      return true;
    }

    return isCreator;
  };

  const isViewOnlyPR = (drive) => {
    return (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      !canManageDrive(drive)
    );
  };

  // Function to check if applications are still open (for application deadline)
  const isApplicationDeadlinePassed = (drive) => {
    // If there's a deadline, use that; otherwise use drive date
    const checkDate = drive.deadline || drive.date;
    if (!checkDate) return false;

    const deadlineDateTime = new Date(checkDate);

    // If drive has a specific time, use it; otherwise assume end of day
    if (drive.time && drive.deadline) {
      const [hours, minutes] = drive.time.split(":");
      deadlineDateTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
    } else {
      // If no time specified, consider applications open until end of deadline day
      deadlineDateTime.setHours(23, 59, 59, 999);
    }

    const currentDateTime = new Date();
    return currentDateTime > deadlineDateTime;
  };

  // Function to check if drive has ended (for filtering purposes)
  const isDriveEnded = (drive) => {
    if (!drive.date) return false;

    const driveDate = new Date(drive.date);
    const currentDate = new Date();

    // If drive has time, use it for comparison
    if (drive.time) {
      const [hours, minutes] = drive.time.split(":").map(Number);
      driveDate.setHours(hours, minutes, 0, 0);
      return currentDate > driveDate;
    } else {
      // If no time specified, consider drive ended at end of day
      driveDate.setHours(23, 59, 59, 999);
      return currentDate > driveDate;
    }
  };

  const handleViewPlacedStudents = async (drive) => {
    try {
      const driveEnded = isDriveEnded(drive);
      
      // Only try to get students from selection rounds if drive has ended
      if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
        const token = localStorage.getItem("token");
        const response = await fetch(
          `http://localhost:5000/api/job-drives/${drive._id}/last-round-students`,
          {
            method: "GET",
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        if (response.ok) {
          const data = await response.json();
          if (data.students && data.students.length > 0) {
            // Create a drive object with the selection round students for modal display
            const driveWithRoundStudents = {
              ...drive,
              placedStudents: data.students, // Use students from final round
            };
            setSelectedDriveForView(driveWithRoundStudents);
            setShowPlacedStudentsViewModal(true);
            return;
          }
        }
      }

      // Always allow viewing manual placed students (regardless of drive end date)
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
        return;
      }

      // If no placed students found from either source
      toast.error("No placed students found for this drive");
    } catch (error) {
      console.error("Error fetching placed students:", error);
      // Fallback to showing manual placed students if API call fails
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
      } else {
        toast.error("Failed to fetch placed students");
      }
    }
  };

  useEffect(() => {
    // Wait for auth context to load before checking user
    if (user === null) {
      // Still loading auth state, don't redirect yet
      return;
    }

    // Allow both placement_representative and placement_officer
    if (
      !user ||
      (user.role !== "placement_representative" &&
        user.role !== "placement_officer" &&
        user.role !== "po")
    ) {
      navigate("/login");
      return;
    }
    fetchAllJobDrives();
  }, [user, navigate]);

  const fetchAllJobDrives = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem("token");
      const response = await axios.get("http://localhost:5000/api/job-drives", {
        headers: { Authorization: `Bearer ${token}` },
      });

      console.log("=== API RESPONSE DEBUG ===");
      console.log("Full response:", response.data);
      console.log("Job drives:", response.data.jobDrives);

      // Debug each drive's creator info
      response.data.jobDrives.forEach((drive, index) => {
        console.log(`Drive ${index + 1} (${drive.companyName}):`, {
          createdBy: drive.createdBy,
          createdById: drive.createdBy?._id,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      setDrives(response.data.jobDrives || []);
    } catch (error) {
      console.error("Error fetching job drives:", error);
      toast.error("Failed to fetch job drives");
    } finally {
      setLoading(false);
    }
  };

  // Add this useEffect to debug the data
  useEffect(() => {
    if (drives.length > 0) {
      console.log("=== DRIVES DEBUG ===");
      drives.forEach((drive, index) => {
        console.log(`Drive ${index + 1}:`, {
          company: drive.companyName,
          createdBy: drive.createdBy,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      console.log("Current user:", {
        role: user?.role,
        department: user?.profile?.department,
        profile: user?.profile,
      });
    }
  }, [drives, user]);

  const handleDeleteDrive = async (driveId) => {
    // Get drive details for the confirmation
    const drive = drives.find((d) => d._id === driveId);
    const driveName = drive
      ? `${drive.companyName} - ${drive.role}`
      : "this job drive";

    // Set up deletion target and show modal
    setDeleteTarget({
      id: driveId,
      name: driveName,
      drive: drive,
    });
    setShowDeleteModal(true);
  };

  const confirmDeleteDrive = async () => {
    if (!deleteTarget) return;

    // For PRs, validate reason
    if (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      (!deleteReason || deleteReason.trim() === "")
    ) {
      toast.error("Reason is required for deletion request");
      return;
    }

    try {
      const token = localStorage.getItem("token");

      // Use the new deletion request API
      await axios.post(
        "http://localhost:5000/api/deletion-requests/request",
        {
          jobDriveId: deleteTarget.id,
          reason: deleteReason || "Administrative deletion",
        },
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );

      if (user?.role === "po" || user?.role === "placement_officer") {
        toast.success("Job drive deleted successfully");
        setDrives(drives.filter((drive) => drive._id !== deleteTarget.id));
      } else {
        toast.success(
          "Deletion request submitted successfully. Awaiting PO approval."
        );
        // Don't remove from list as it's pending approval
      }

      // Close modal and reset state
      setShowDeleteModal(false);
      setDeleteTarget(null);
      setDeleteReason("");
    } catch (error) {
      console.error("Delete error:", error);
      if (error.response?.data?.message) {
        toast.error(error.response.data.message);
      } else {
        toast.error("Failed to process deletion request");
      }
    }
  };

  const cancelDelete = () => {
    setShowDeleteModal(false);
    setDeleteTarget(null);
    setDeleteReason("");
  };

  const handleEditDrive = (driveId) => {
    navigate(`/pr/edit-job/${driveId}?returnTo=/all-job-drives`);
  };

  const handleViewDetails = (drive) => {
    console.log("=== DRIVE DETAILS DEBUG ===");
    console.log("Full drive object:", JSON.stringify(drive, null, 2));
    console.log("Eligibility object:", drive.eligibility);
    console.log("Min CGPA field:", drive.eligibility?.minCGPA);
    console.log("CGPA field:", drive.eligibility?.cgpa);
    console.log("Test Details:", drive.testDetails);
    console.log("Interview Process:", drive.interviewProcess);
    console.log("Bond:", drive.bond);

    setSelectedDrive(drive);
    setShowModal(true);
  };

  const closeModal = () => {
    setShowModal(false);
    setSelectedDrive(null);
  };

  const getFilteredDrives = () => {
    console.log("=== ALL JOB DRIVES FILTERING ===");
    console.log("Total drives:", drives.length);
    console.log("Current filter:", filter);
    console.log("User role:", user?.role);

    return drives.filter((drive) => {
      const driveEnded = isDriveEnded(drive);
      console.log(
        `Drive ${drive.companyName}: ended=${driveEnded}, date=${drive.date}, time=${drive.time}`
      );

      if (filter === "upcoming") {
        return !driveEnded; // Not ended yet
      } else if (filter === "past") {
        return driveEnded; // Drive has ended
      }
      return true; // 'all' filter
    });
  };

  const handleEditStudent = (student, index) => {
    setEditingStudent(index);
    setEditStudentData({
      name: student.name,
      rollNumber: student.rollNumber,
      department: student.department || "",
      email: student.email,
      mobileNumber: student.mobileNumber || "",
    });
  };

  const handleSaveEdit = async (index) => {
    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/update-placed-student`,
        {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({
            index: index,
            studentData: editStudentData,
          }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student updated successfully!");
        setEditingStudent(null);

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to update student");
      }
    } catch (error) {
      console.error("Error updating student:", error);
      toast.error("Error updating student");
    }
  };

  const handleDeleteStudent = async (index) => {
    setDeleteStudentIndex(index);
    setShowDeleteStudentModal(true);
  };

  const confirmDeleteStudent = async () => {
    if (deleteStudentIndex === null) return;

    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/delete-placed-student`,
        {
          method: "DELETE",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({ index: deleteStudentIndex }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student deleted successfully!");

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to delete student");
      }
    } catch (error) {
      console.error("Error deleting student:", error);
      toast.error("Error deleting student");
    } finally {
      setShowDeleteStudentModal(false);
      setDeleteStudentIndex(null);
    }
  };

  const cancelDeleteStudent = () => {
    setShowDeleteStudentModal(false);
    setDeleteStudentIndex(null);
  };

  const downloadCSV = () => {
    if (!selectedDriveForView?.placedStudents?.length) {
      toast.error("No data to download");
      return;
    }

    const headers = [
      "S.No",
      "Name",
      "Roll Number",
      "Department",
      "Email",
      "Mobile",
      "Added On",
    ];
    const csvContent = [
      headers.join(","),
      ...selectedDriveForView.placedStudents.map((student, index) =>
        [
          index + 1,
          `"${student.name}"`,
          `"${student.rollNumber}"`,
          `"${student.department || "N/A"}"`,
          `"${student.email}"`,
          `"${student.mobileNumber || "N/A"}"`,
          `"${
            student.addedAt
              ? new Date(student.addedAt).toLocaleDateString()
              : "N/A"
          }"`,
        ].join(",")
      ),
    ].join("\n");

    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute(
      "download",
      `${selectedDriveForView.companyName}_placed_students.csv`
    );
    link.style.visibility = "hidden";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const handleManageRounds = (drive, roundIndex) => {
    // For same department PRs - full management access
    setSelectedJobForRounds(drive);
</original_code>```

```
import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../contexts/AuthContext";
import axios from "axios";
import toast from "react-hot-toast";
import PRJobCard from "./PRJobCard";
import RoundManagementModal from "./RoundManagementModal";
import {
  useJobDriveUpdates,
  useDeletionRequestUpdates,
  useApplicationUpdates,
  useSocketConnection,
  useModalUpdates,
  useRoundUpdates,
} from "../hooks/useSocket";

const normalizeDepartment = (dept) => {
  if (!dept) return null;
  return dept.toLowerCase().trim();
};

const AllJobDrives = () => {
  const { user } = useAuth();
  const navigate = useNavigate();
  const [drives, setDrives] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState("all");
  const [showModal, setShowModal] = useState(false);
  const [selectedDrive, setSelectedDrive] = useState(null);
  const [showPlacedStudentsViewModal, setShowPlacedStudentsViewModal] =
    useState(false);
  const [selectedDriveForView, setSelectedDriveForView] = useState(null);
  const [showRoundModal, setShowRoundModal] = useState(false);
  const [selectedJobForRounds, setSelectedJobForRounds] = useState(null);
  const [selectedRoundIndex, setSelectedRoundIndex] = useState(null);
  const [showRoundStudentsModal, setShowRoundStudentsModal] = useState(false);
  const [selectedRound, setSelectedRound] = useState(null);
  const [selectedJobForRoundView, setSelectedJobForRoundView] = useState(null);
  const [showManageRoundsModal, setShowManageRoundsModal] = useState(false);
  const [selectedDriveForRounds, setSelectedDriveForRounds] = useState(null);
  const [selectedRoundForManagement, setSelectedRoundForManagement] =
    useState(null);
  const [roundApplicants, setRoundApplicants] = useState([]);
  const [selectedStudentsForRound, setSelectedStudentsForRound] = useState([]);
  const [loadingApplicants, setLoadingApplicants] = useState(false);

  // Deletion confirmation modal states
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [deleteTarget, setDeleteTarget] = useState(null);
  const [deleteReason, setDeleteReason] = useState("");

  // Student deletion states
  const [showDeleteStudentModal, setShowDeleteStudentModal] = useState(false);
  const [deleteStudentIndex, setDeleteStudentIndex] = useState(null);

  // Helper function to count placed students (matches PO dashboard logic)
  const getPlacedStudentsCount = (drive) => {
    // Check if drive has ended first
    const driveEnded = isDriveEnded(drive);
    
    // Only count from selection rounds if drive has ended
    if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
      const lastRound = drive.selectionRounds[drive.selectionRounds.length - 1];
      const countFromRounds = lastRound.selectedStudents?.length || 0;
      if (countFromRounds > 0) {
        return countFromRounds;
      }
    }
    
    // Always allow manual placed students (regardless of drive end date)
    return drive.placedStudents?.length || 0;
  };

  // Socket connection and real-time updates
  useSocketConnection(user?.role);

  // Handle real-time job drive updates
  useJobDriveUpdates((data) => {
    const { action } = data;

    // Refetch all job drives to get the latest data
    if (
      action === "created" ||
      action === "updated" ||
      action === "deleted" ||
      action === "application_submitted"
    ) {
      fetchAllJobDrives();
    }
  });

  // Handle real-time deletion request updates
  useDeletionRequestUpdates((data) => {
    const { action } = data;

    // Refetch all job drives when deletion is approved
    if (action === "approved") {
      fetchAllJobDrives();
    }
  });

  // Handle real-time application updates
  useApplicationUpdates((data) => {
    // Refetch drives when application status changes
    fetchAllJobDrives();
  });

  // Handle real-time modal updates
  useModalUpdates(selectedDrive?._id, (updatedDrive, action) => {
    if (action === 'updated') {
      // Update the selected drive data in the modal
      setSelectedDrive(updatedDrive);
    }
  });

  // Handle real-time round updates
  useRoundUpdates((data) => {
    const { action, jobDrive } = data;
    
    // If modal is open for this drive, refresh the selected drive data
    if (selectedDrive && jobDrive && (jobDrive._id === selectedDrive._id || jobDrive.id === selectedDrive._id)) {
      setSelectedDrive(jobDrive);
    }
    
    // If round management modal is open, refresh that too
    if (selectedDriveForRounds && jobDrive && (jobDrive._id === selectedDriveForRounds._id || jobDrive.id === selectedDriveForRounds._id)) {
      setSelectedDriveForRounds(jobDrive);
    }
    
    // Refresh the drives list
    fetchAllJobDrives();
  });

  // Add these helper functions at the top of the component
  const isDriveCreator = (drive) => {
    const isCreator = drive.createdBy?._id === user?.id;
    console.log("=== CREATOR CHECK ===");
    console.log("Drive:", drive.companyName);
    console.log("Drive creator ID:", drive.createdBy?._id);
    console.log("Current user ID:", user?.id);
    console.log("Is creator:", isCreator);
    return isCreator;
  };

  const canManageDrive = (drive) => {
    // If no createdBy info, nobody can manage
    if (!drive.createdBy) {
      console.log("❌ No creator info - no management access");
      return false;
    }

    // Check if user created the drive
    const isCreator = isDriveCreator(drive);

    // For PRs - also check department access
    if (user?.role === "placement_representative" || user?.role === "pr") {
      const userDept = normalizeDepartment(user.profile?.department);
      const creatorDept = normalizeDepartment(
        drive.createdBy?.profile?.department
      );

      console.log("=== MANAGE ACCESS CHECK ===");
      console.log("Drive:", drive.companyName);
      console.log("User:", user.email);
      console.log("User Dept (normalized):", userDept);
      console.log("Creator:", drive.createdBy.email);
      console.log("Creator Dept (normalized):", creatorDept);
      console.log("Is creator:", isCreator);

      // Allow if same department OR if user created the drive
      if (isCreator || (userDept && creatorDept && userDept === creatorDept)) {
        console.log(
          "✅ Management access granted - same department or creator"
        );
        return true;
      } else {
        console.log("❌ Different department and not creator - access denied");
        return false;
      }
    }

    // For POs - they can manage everything
    if (user?.role === "po" || user?.role === "placement_officer") {
      return true;
    }

    return isCreator;
  };

  const isViewOnlyPR = (drive) => {
    return (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      !canManageDrive(drive)
    );
  };

  // Function to check if applications are still open (for application deadline)
  const isApplicationDeadlinePassed = (drive) => {
    // If there's a deadline, use that; otherwise use drive date
    const checkDate = drive.deadline || drive.date;
    if (!checkDate) return false;

    const deadlineDateTime = new Date(checkDate);

    // If drive has a specific time, use it; otherwise assume end of day
    if (drive.time && drive.deadline) {
      const [hours, minutes] = drive.time.split(":");
      deadlineDateTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
    } else {
      // If no time specified, consider applications open until end of deadline day
      deadlineDateTime.setHours(23, 59, 59, 999);
    }

    const currentDateTime = new Date();
    return currentDateTime > deadlineDateTime;
  };

  // Function to check if drive has ended (for filtering purposes)
  const isDriveEnded = (drive) => {
    if (!drive.date) return false;

    const driveDate = new Date(drive.date);
    const currentDate = new Date();

    // If drive has time, use it for comparison
    if (drive.time) {
      const [hours, minutes] = drive.time.split(":").map(Number);
      driveDate.setHours(hours, minutes, 0, 0);
      return currentDate > driveDate;
    } else {
      // If no time specified, consider drive ended at end of day
      driveDate.setHours(23, 59, 59, 999);
      return currentDate > driveDate;
    }
  };

  const handleViewPlacedStudents = async (drive) => {
    try {
      const driveEnded = isDriveEnded(drive);
      
      // Only try to get students from selection rounds if drive has ended
      if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
        const token = localStorage.getItem("token");
        const response = await fetch(
          `http://localhost:5000/api/job-drives/${drive._id}/last-round-students`,
          {
            method: "GET",
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        if (response.ok) {
          const data = await response.json();
          if (data.students && data.students.length > 0) {
            // Create a drive object with the selection round students for modal display
            const driveWithRoundStudents = {
              ...drive,
              placedStudents: data.students, // Use students from final round
            };
            setSelectedDriveForView(driveWithRoundStudents);
            setShowPlacedStudentsViewModal(true);
            return;
          }
        }
      }

      // Always allow viewing manual placed students (regardless of drive end date)
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
        return;
      }

      // If no placed students found from either source
      toast.error("No placed students found for this drive");
    } catch (error) {
      console.error("Error fetching placed students:", error);
      // Fallback to showing manual placed students if API call fails
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
      } else {
        toast.error("Failed to fetch placed students");
      }
    }
  };

  useEffect(() => {
    // Wait for auth context to load before checking user
    if (user === null) {
      // Still loading auth state, don't redirect yet
      return;
    }

    // Allow both placement_representative and placement_officer
    if (
      !user ||
      (user.role !== "placement_representative" &&
        user.role !== "placement_officer" &&
        user.role !== "po")
    ) {
      navigate("/login");
      return;
    }
    fetchAllJobDrives();
  }, [user, navigate]);

  const fetchAllJobDrives = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem("token");
      const response = await axios.get("http://localhost:5000/api/job-drives", {
        headers: { Authorization: `Bearer ${token}` },
      });

      console.log("=== API RESPONSE DEBUG ===");
      console.log("Full response:", response.data);
      console.log("Job drives:", response.data.jobDrives);

      // Debug each drive's creator info
      response.data.jobDrives.forEach((drive, index) => {
        console.log(`Drive ${index + 1} (${drive.companyName}):`, {
          createdBy: drive.createdBy,
          createdById: drive.createdBy?._id,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      setDrives(response.data.jobDrives || []);
    } catch (error) {
      console.error("Error fetching job drives:", error);
      toast.error("Failed to fetch job drives");
    } finally {
      setLoading(false);
    }
  };

  // Add this useEffect to debug the data
  useEffect(() => {
    if (drives.length > 0) {
      console.log("=== DRIVES DEBUG ===");
      drives.forEach((drive, index) => {
        console.log(`Drive ${index + 1}:`, {
          company: drive.companyName,
          createdBy: drive.createdBy,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      console.log("Current user:", {
        role: user?.role,
        department: user?.profile?.department,
        profile: user?.profile,
      });
    }
  }, [drives, user]);

  const handleDeleteDrive = async (driveId) => {
    // Get drive details for the confirmation
    const drive = drives.find((d) => d._id === driveId);
    const driveName = drive
      ? `${drive.companyName} - ${drive.role}`
      : "this job drive";

    // Set up deletion target and show modal
    setDeleteTarget({
      id: driveId,
      name: driveName,
      drive: drive,
    });
    setShowDeleteModal(true);
  };

  const confirmDeleteDrive = async () => {
    if (!deleteTarget) return;

    // For PRs, validate reason
    if (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      (!deleteReason || deleteReason.trim() === "")
    ) {
      toast.error("Reason is required for deletion request");
      return;
    }

    try {
      const token = localStorage.getItem("token");

      // Use the new deletion request API
      await axios.post(
        "http://localhost:5000/api/deletion-requests/request",
        {
          jobDriveId: deleteTarget.id,
          reason: deleteReason || "Administrative deletion",
        },
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );

      if (user?.role === "po" || user?.role === "placement_officer") {
        toast.success("Job drive deleted successfully");
        setDrives(drives.filter((drive) => drive._id !== deleteTarget.id));
      } else {
        toast.success(
          "Deletion request submitted successfully. Awaiting PO approval."
        );
        // Don't remove from list as it's pending approval
      }

      // Close modal and reset state
      setShowDeleteModal(false);
      setDeleteTarget(null);
      setDeleteReason("");
    } catch (error) {
      console.error("Delete error:", error);
      if (error.response?.data?.message) {
        toast.error(error.response.data.message);
      } else {
        toast.error("Failed to process deletion request");
      }
    }
  };

  const cancelDelete = () => {
    setShowDeleteModal(false);
    setDeleteTarget(null);
    setDeleteReason("");
  };

  const handleEditDrive = (driveId) => {
    navigate(`/pr/edit-job/${driveId}?returnTo=/all-job-drives`);
  };

  const handleViewDetails = (drive) => {
    console.log("=== DRIVE DETAILS DEBUG ===");
    console.log("Full drive object:", JSON.stringify(drive, null, 2));
    console.log("Eligibility object:", drive.eligibility);
    console.log("Min CGPA field:", drive.eligibility?.minCGPA);
    console.log("CGPA field:", drive.eligibility?.cgpa);
    console.log("Test Details:", drive.testDetails);
    console.log("Interview Process:", drive.interviewProcess);
    console.log("Bond:", drive.bond);

    setSelectedDrive(drive);
    setShowModal(true);
  };

  const closeModal = () => {
    setShowModal(false);
    setSelectedDrive(null);
  };

  const getFilteredDrives = () => {
    console.log("=== ALL JOB DRIVES FILTERING ===");
    console.log("Total drives:", drives.length);
    console.log("Current filter:", filter);
    console.log("User role:", user?.role);

    return drives.filter((drive) => {
      const driveEnded = isDriveEnded(drive);
      console.log(
        `Drive ${drive.companyName}: ended=${driveEnded}, date=${drive.date}, time=${drive.time}`
      );

      if (filter === "upcoming") {
        return !driveEnded; // Not ended yet
      } else if (filter === "past") {
        return driveEnded; // Drive has ended
      }
      return true; // 'all' filter
    });
  };

  const handleEditStudent = (student, index) => {
    setEditingStudent(index);
    setEditStudentData({
      name: student.name,
      rollNumber: student.rollNumber,
      department: student.department || "",
      email: student.email,
      mobileNumber: student.mobileNumber || "",
    });
  };

  const handleSaveEdit = async (index) => {
    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/update-placed-student`,
        {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({
            index: index,
            studentData: editStudentData,
          }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student updated successfully!");
        setEditingStudent(null);

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to update student");
      }
    } catch (error) {
      console.error("Error updating student:", error);
      toast.error("Error updating student");
    }
  };

  const handleDeleteStudent = async (index) => {
    setDeleteStudentIndex(index);
    setShowDeleteStudentModal(true);
  };

  const confirmDeleteStudent = async () => {
    if (deleteStudentIndex === null) return;

    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/delete-placed-student`,
        {
          method: "DELETE",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({ index: deleteStudentIndex }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student deleted successfully!");

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to delete student");
      }
    } catch (error) {
      console.error("Error deleting student:", error);
      toast.error("Error deleting student");
    } finally {
      setShowDeleteStudentModal(false);
      setDeleteStudentIndex(null);
    }
  };

  const cancelDeleteStudent = () => {
    setShowDeleteStudentModal(false);
    setDeleteStudentIndex(null);
  };

  const downloadCSV = () => {
    if (!selectedDriveForView?.placedStudents?.length) {
      toast.error("No data to download");
      return;
    }

    const headers = [
      "S.No",
      "Name",
      "Roll Number",
      "Department",
      "Email",
      "Mobile",
      "Added On",
    ];
    const csvContent = [
      headers.join(","),
      ...selectedDriveForView.placedStudents.map((student, index) =>
        [
          index + 1,
          `"${student.name}"`,
          `"${student.rollNumber}"`,
          `"${student.department || "N/A"}"`,
          `"${student.email}"`,
          `"${student.mobileNumber || "N/A"}"`,
          `"${
            student.addedAt
              ? new Date(student.addedAt).toLocaleDateString()
              : "N/A"
          }"`,
        ].join(",")
      ),
    ].join("\n");

    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute(
      "download",
      `${selectedDriveForView.companyName}_placed_students.csv`
    );
    link.style.visibility = "hidden";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const handleManageRounds = (drive, roundIndex) => {
    // For same department PRs - full management access
    setSelectedJobForRounds(drive);
</original_code>```

```
import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../contexts/AuthContext";
import axios from "axios";
import toast from "react-hot-toast";
import PRJobCard from "./PRJobCard";
import RoundManagementModal from "./RoundManagementModal";
import {
  useJobDriveUpdates,
  useDeletionRequestUpdates,
  useApplicationUpdates,
  useSocketConnection,
  useModalUpdates,
  useRoundUpdates,
} from "../hooks/useSocket";

const normalizeDepartment = (dept) => {
  if (!dept) return null;
  return dept.toLowerCase().trim();
};

const AllJobDrives = () => {
  const { user } = useAuth();
  const navigate = useNavigate();
  const [drives, setDrives] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState("all");
  const [showModal, setShowModal] = useState(false);
  const [selectedDrive, setSelectedDrive] = useState(null);
  const [showPlacedStudentsViewModal, setShowPlacedStudentsViewModal] =
    useState(false);
  const [selectedDriveForView, setSelectedDriveForView] = useState(null);
  const [showRoundModal, setShowRoundModal] = useState(false);
  const [selectedJobForRounds, setSelectedJobForRounds] = useState(null);
  const [selectedRoundIndex, setSelectedRoundIndex] = useState(null);
  const [showRoundStudentsModal, setShowRoundStudentsModal] = useState(false);
  const [selectedRound, setSelectedRound] = useState(null);
  const [selectedJobForRoundView, setSelectedJobForRoundView] = useState(null);
  const [showManageRoundsModal, setShowManageRoundsModal] = useState(false);
  const [selectedDriveForRounds, setSelectedDriveForRounds] = useState(null);
  const [selectedRoundForManagement, setSelectedRoundForManagement] =
    useState(null);
  const [roundApplicants, setRoundApplicants] = useState([]);
  const [selectedStudentsForRound, setSelectedStudentsForRound] = useState([]);
  const [loadingApplicants, setLoadingApplicants] = useState(false);

  // Deletion confirmation modal states
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [deleteTarget, setDeleteTarget] = useState(null);
  const [deleteReason, setDeleteReason] = useState("");

  // Student deletion states
  const [showDeleteStudentModal, setShowDeleteStudentModal] = useState(false);
  const [deleteStudentIndex, setDeleteStudentIndex] = useState(null);

  // Helper function to count placed students (matches PO dashboard logic)
  const getPlacedStudentsCount = (drive) => {
    // Check if drive has ended first
    const driveEnded = isDriveEnded(drive);
    
    // Only count from selection rounds if drive has ended
    if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
      const lastRound = drive.selectionRounds[drive.selectionRounds.length - 1];
      const countFromRounds = lastRound.selectedStudents?.length || 0;
      if (countFromRounds > 0) {
        return countFromRounds;
      }
    }
    
    // Always allow manual placed students (regardless of drive end date)
    return drive.placedStudents?.length || 0;
  };

  // Socket connection and real-time updates
  useSocketConnection(user?.role);

  // Handle real-time job drive updates
  useJobDriveUpdates((data) => {
    const { action } = data;

    // Refetch all job drives to get the latest data
    if (
      action === "created" ||
      action === "updated" ||
      action === "deleted" ||
      action === "application_submitted"
    ) {
      fetchAllJobDrives();
    }
  });

  // Handle real-time deletion request updates
  useDeletionRequestUpdates((data) => {
    const { action } = data;

    // Refetch all job drives when deletion is approved
    if (action === "approved") {
      fetchAllJobDrives();
    }
  });

  // Handle real-time application updates
  useApplicationUpdates((data) => {
    // Refetch drives when application status changes
    fetchAllJobDrives();
  });

  // Handle real-time modal updates
  useModalUpdates(selectedDrive?._id, (updatedDrive, action) => {
    if (action === 'updated') {
      // Update the selected drive data in the modal
      setSelectedDrive(updatedDrive);
    }
  });

  // Handle real-time round updates
  useRoundUpdates((data) => {
    const { action, jobDrive } = data;
    
    // If modal is open for this drive, refresh the selected drive data
    if (selectedDrive && jobDrive && (jobDrive._id === selectedDrive._id || jobDrive.id === selectedDrive._id)) {
      setSelectedDrive(jobDrive);
    }
    
    // If round management modal is open, refresh that too
    if (selectedDriveForRounds && jobDrive && (jobDrive._id === selectedDriveForRounds._id || jobDrive.id === selectedDriveForRounds._id)) {
      setSelectedDriveForRounds(jobDrive);
    }
    
    // Refresh the drives list
    fetchAllJobDrives();
  });

  // Add these helper functions at the top of the component
  const isDriveCreator = (drive) => {
    const isCreator = drive.createdBy?._id === user?.id;
    console.log("=== CREATOR CHECK ===");
    console.log("Drive:", drive.companyName);
    console.log("Drive creator ID:", drive.createdBy?._id);
    console.log("Current user ID:", user?.id);
    console.log("Is creator:", isCreator);
    return isCreator;
  };

  const canManageDrive = (drive) => {
    // If no createdBy info, nobody can manage
    if (!drive.createdBy) {
      console.log("❌ No creator info - no management access");
      return false;
    }

    // Check if user created the drive
    const isCreator = isDriveCreator(drive);

    // For PRs - also check department access
    if (user?.role === "placement_representative" || user?.role === "pr") {
      const userDept = normalizeDepartment(user.profile?.department);
      const creatorDept = normalizeDepartment(
        drive.createdBy?.profile?.department
      );

      console.log("=== MANAGE ACCESS CHECK ===");
      console.log("Drive:", drive.companyName);
      console.log("User:", user.email);
      console.log("User Dept (normalized):", userDept);
      console.log("Creator:", drive.createdBy.email);
      console.log("Creator Dept (normalized):", creatorDept);
      console.log("Is creator:", isCreator);

      // Allow if same department OR if user created the drive
      if (isCreator || (userDept && creatorDept && userDept === creatorDept)) {
        console.log(
          "✅ Management access granted - same department or creator"
        );
        return true;
      } else {
        console.log("❌ Different department and not creator - access denied");
        return false;
      }
    }

    // For POs - they can manage everything
    if (user?.role === "po" || user?.role === "placement_officer") {
      return true;
    }

    return isCreator;
  };

  const isViewOnlyPR = (drive) => {
    return (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      !canManageDrive(drive)
    );
  };

  // Function to check if applications are still open (for application deadline)
  const isApplicationDeadlinePassed = (drive) => {
    // If there's a deadline, use that; otherwise use drive date
    const checkDate = drive.deadline || drive.date;
    if (!checkDate) return false;

    const deadlineDateTime = new Date(checkDate);

    // If drive has a specific time, use it; otherwise assume end of day
    if (drive.time && drive.deadline) {
      const [hours, minutes] = drive.time.split(":");
      deadlineDateTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
    } else {
      // If no time specified, consider applications open until end of deadline day
      deadlineDateTime.setHours(23, 59, 59, 999);
    }

    const currentDateTime = new Date();
    return currentDateTime > deadlineDateTime;
  };

  // Function to check if drive has ended (for filtering purposes)
  const isDriveEnded = (drive) => {
    if (!drive.date) return false;

    const driveDate = new Date(drive.date);
    const currentDate = new Date();

    // If drive has time, use it for comparison
    if (drive.time) {
      const [hours, minutes] = drive.time.split(":").map(Number);
      driveDate.setHours(hours, minutes, 0, 0);
      return currentDate > driveDate;
    } else {
      // If no time specified, consider drive ended at end of day
      driveDate.setHours(23, 59, 59, 999);
      return currentDate > driveDate;
    }
  };

  const handleViewPlacedStudents = async (drive) => {
    try {
      const driveEnded = isDriveEnded(drive);
      
      // Only try to get students from selection rounds if drive has ended
      if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
        const token = localStorage.getItem("token");
        const response = await fetch(
          `http://localhost:5000/api/job-drives/${drive._id}/last-round-students`,
          {
            method: "GET",
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        if (response.ok) {
          const data = await response.json();
          if (data.students && data.students.length > 0) {
            // Create a drive object with the selection round students for modal display
            const driveWithRoundStudents = {
              ...drive,
              placedStudents: data.students, // Use students from final round
            };
            setSelectedDriveForView(driveWithRoundStudents);
            setShowPlacedStudentsViewModal(true);
            return;
          }
        }
      }

      // Always allow viewing manual placed students (regardless of drive end date)
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
        return;
      }

      // If no placed students found from either source
      toast.error("No placed students found for this drive");
    } catch (error) {
      console.error("Error fetching placed students:", error);
      // Fallback to showing manual placed students if API call fails
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
      } else {
        toast.error("Failed to fetch placed students");
      }
    }
  };

  useEffect(() => {
    // Wait for auth context to load before checking user
    if (user === null) {
      // Still loading auth state, don't redirect yet
      return;
    }

    // Allow both placement_representative and placement_officer
    if (
      !user ||
      (user.role !== "placement_representative" &&
        user.role !== "placement_officer" &&
        user.role !== "po")
    ) {
      navigate("/login");
      return;
    }
    fetchAllJobDrives();
  }, [user, navigate]);

  const fetchAllJobDrives = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem("token");
      const response = await axios.get("http://localhost:5000/api/job-drives", {
        headers: { Authorization: `Bearer ${token}` },
      });

      console.log("=== API RESPONSE DEBUG ===");
      console.log("Full response:", response.data);
      console.log("Job drives:", response.data.jobDrives);

      // Debug each drive's creator info
      response.data.jobDrives.forEach((drive, index) => {
        console.log(`Drive ${index + 1} (${drive.companyName}):`, {
          createdBy: drive.createdBy,
          createdById: drive.createdBy?._id,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      setDrives(response.data.jobDrives || []);
    } catch (error) {
      console.error("Error fetching job drives:", error);
      toast.error("Failed to fetch job drives");
    } finally {
      setLoading(false);
    }
  };

  // Add this useEffect to debug the data
  useEffect(() => {
    if (drives.length > 0) {
      console.log("=== DRIVES DEBUG ===");
      drives.forEach((drive, index) => {
        console.log(`Drive ${index + 1}:`, {
          company: drive.companyName,
          createdBy: drive.createdBy,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      console.log("Current user:", {
        role: user?.role,
        department: user?.profile?.department,
        profile: user?.profile,
      });
    }
  }, [drives, user]);

  const handleDeleteDrive = async (driveId) => {
    // Get drive details for the confirmation
    const drive = drives.find((d) => d._id === driveId);
    const driveName = drive
      ? `${drive.companyName} - ${drive.role}`
      : "this job drive";

    // Set up deletion target and show modal
    setDeleteTarget({
      id: driveId,
      name: driveName,
      drive: drive,
    });
    setShowDeleteModal(true);
  };

  const confirmDeleteDrive = async () => {
    if (!deleteTarget) return;

    // For PRs, validate reason
    if (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      (!deleteReason || deleteReason.trim() === "")
    ) {
      toast.error("Reason is required for deletion request");
      return;
    }

    try {
      const token = localStorage.getItem("token");

      // Use the new deletion request API
      await axios.post(
        "http://localhost:5000/api/deletion-requests/request",
        {
          jobDriveId: deleteTarget.id,
          reason: deleteReason || "Administrative deletion",
        },
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );

      if (user?.role === "po" || user?.role === "placement_officer") {
        toast.success("Job drive deleted successfully");
        setDrives(drives.filter((drive) => drive._id !== deleteTarget.id));
      } else {
        toast.success(
          "Deletion request submitted successfully. Awaiting PO approval."
        );
        // Don't remove from list as it's pending approval
      }

      // Close modal and reset state
      setShowDeleteModal(false);
      setDeleteTarget(null);
      setDeleteReason("");
    } catch (error) {
      console.error("Delete error:", error);
      if (error.response?.data?.message) {
        toast.error(error.response.data.message);
      } else {
        toast.error("Failed to process deletion request");
      }
    }
  };

  const cancelDelete = () => {
    setShowDeleteModal(false);
    setDeleteTarget(null);
    setDeleteReason("");
  };

  const handleEditDrive = (driveId) => {
    navigate(`/pr/edit-job/${driveId}?returnTo=/all-job-drives`);
  };

  const handleViewDetails = (drive) => {
    console.log("=== DRIVE DETAILS DEBUG ===");
    console.log("Full drive object:", JSON.stringify(drive, null, 2));
    console.log("Eligibility object:", drive.eligibility);
    console.log("Min CGPA field:", drive.eligibility?.minCGPA);
    console.log("CGPA field:", drive.eligibility?.cgpa);
    console.log("Test Details:", drive.testDetails);
    console.log("Interview Process:", drive.interviewProcess);
    console.log("Bond:", drive.bond);

    setSelectedDrive(drive);
    setShowModal(true);
  };

  const closeModal = () => {
    setShowModal(false);
    setSelectedDrive(null);
  };

  const getFilteredDrives = () => {
    console.log("=== ALL JOB DRIVES FILTERING ===");
    console.log("Total drives:", drives.length);
    console.log("Current filter:", filter);
    console.log("User role:", user?.role);

    return drives.filter((drive) => {
      const driveEnded = isDriveEnded(drive);
      console.log(
        `Drive ${drive.companyName}: ended=${driveEnded}, date=${drive.date}, time=${drive.time}`
      );

      if (filter === "upcoming") {
        return !driveEnded; // Not ended yet
      } else if (filter === "past") {
        return driveEnded; // Drive has ended
      }
      return true; // 'all' filter
    });
  };

  const handleEditStudent = (student, index) => {
    setEditingStudent(index);
    setEditStudentData({
      name: student.name,
      rollNumber: student.rollNumber,
      department: student.department || "",
      email: student.email,
      mobileNumber: student.mobileNumber || "",
    });
  };

  const handleSaveEdit = async (index) => {
    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/update-placed-student`,
        {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({
            index: index,
            studentData: editStudentData,
          }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student updated successfully!");
        setEditingStudent(null);

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to update student");
      }
    } catch (error) {
      console.error("Error updating student:", error);
      toast.error("Error updating student");
    }
  };

  const handleDeleteStudent = async (index) => {
    setDeleteStudentIndex(index);
    setShowDeleteStudentModal(true);
  };

  const confirmDeleteStudent = async () => {
    if (deleteStudentIndex === null) return;

    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/delete-placed-student`,
        {
          method: "DELETE",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({ index: deleteStudentIndex }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student deleted successfully!");

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to delete student");
      }
    } catch (error) {
      console.error("Error deleting student:", error);
      toast.error("Error deleting student");
    } finally {
      setShowDeleteStudentModal(false);
      setDeleteStudentIndex(null);
    }
  };

  const cancelDeleteStudent = () => {
    setShowDeleteStudentModal(false);
    setDeleteStudentIndex(null);
  };

  const downloadCSV = () => {
    if (!selectedDriveForView?.placedStudents?.length) {
      toast.error("No data to download");
      return;
    }

    const headers = [
      "S.No",
      "Name",
      "Roll Number",
      "Department",
      "Email",
      "Mobile",
      "Added On",
    ];
    const csvContent = [
      headers.join(","),
      ...selectedDriveForView.placedStudents.map((student, index) =>
        [
          index + 1,
          `"${student.name}"`,
          `"${student.rollNumber}"`,
          `"${student.department || "N/A"}"`,
          `"${student.email}"`,
          `"${student.mobileNumber || "N/A"}"`,
          `"${
            student.addedAt
              ? new Date(student.addedAt).toLocaleDateString()
              : "N/A"
          }"`,
        ].join(",")
      ),
    ].join("\n");

    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute(
      "download",
      `${selectedDriveForView.companyName}_placed_students.csv`
    );
    link.style.visibility = "hidden";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const handleManageRounds = (drive, roundIndex) => {
    // For same department PRs - full management access
    setSelectedJobForRounds(drive);
</original_code>```

```
import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../contexts/AuthContext";
import axios from "axios";
import toast from "react-hot-toast";
import PRJobCard from "./PRJobCard";
import RoundManagementModal from "./RoundManagementModal";
import {
  useJobDriveUpdates,
  useDeletionRequestUpdates,
  useApplicationUpdates,
  useSocketConnection,
  useModalUpdates,
  useRoundUpdates,
} from "../hooks/useSocket";

const normalizeDepartment = (dept) => {
  if (!dept) return null;
  return dept.toLowerCase().trim();
};

const AllJobDrives = () => {
  const { user } = useAuth();
  const navigate = useNavigate();
  const [drives, setDrives] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState("all");
  const [showModal, setShowModal] = useState(false);
  const [selectedDrive, setSelectedDrive] = useState(null);
  const [showPlacedStudentsViewModal, setShowPlacedStudentsViewModal] =
    useState(false);
  const [selectedDriveForView, setSelectedDriveForView] = useState(null);
  const [showRoundModal, setShowRoundModal] = useState(false);
  const [selectedJobForRounds, setSelectedJobForRounds] = useState(null);
  const [selectedRoundIndex, setSelectedRoundIndex] = useState(null);
  const [showRoundStudentsModal, setShowRoundStudentsModal] = useState(false);
  const [selectedRound, setSelectedRound] = useState(null);
  const [selectedJobForRoundView, setSelectedJobForRoundView] = useState(null);
  const [showManageRoundsModal, setShowManageRoundsModal] = useState(false);
  const [selectedDriveForRounds, setSelectedDriveForRounds] = useState(null);
  const [selectedRoundForManagement, setSelectedRoundForManagement] =
    useState(null);
  const [roundApplicants, setRoundApplicants] = useState([]);
  const [selectedStudentsForRound, setSelectedStudentsForRound] = useState([]);
  const [loadingApplicants, setLoadingApplicants] = useState(false);

  // Deletion confirmation modal states
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [deleteTarget, setDeleteTarget] = useState(null);
  const [deleteReason, setDeleteReason] = useState("");

  // Student deletion states
  const [showDeleteStudentModal, setShowDeleteStudentModal] = useState(false);
  const [deleteStudentIndex, setDeleteStudentIndex] = useState(null);

  // Helper function to count placed students (matches PO dashboard logic)
  const getPlacedStudentsCount = (drive) => {
    // Check if drive has ended first
    const driveEnded = isDriveEnded(drive);
    
    // Only count from selection rounds if drive has ended
    if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
      const lastRound = drive.selectionRounds[drive.selectionRounds.length - 1];
      const countFromRounds = lastRound.selectedStudents?.length || 0;
      if (countFromRounds > 0) {
        return countFromRounds;
      }
    }
    
    // Always allow manual placed students (regardless of drive end date)
    return drive.placedStudents?.length || 0;
  };

  // Socket connection and real-time updates
  useSocketConnection(user?.role);

  // Handle real-time job drive updates
  useJobDriveUpdates((data) => {
    const { action } = data;

    // Refetch all job drives to get the latest data
    if (
      action === "created" ||
      action === "updated" ||
      action === "deleted" ||
      action === "application_submitted"
    ) {
      fetchAllJobDrives();
    }
  });

  // Handle real-time deletion request updates
  useDeletionRequestUpdates((data) => {
    const { action } = data;

    // Refetch all job drives when deletion is approved
    if (action === "approved") {
      fetchAllJobDrives();
    }
  });

  // Handle real-time application updates
  useApplicationUpdates((data) => {
    // Refetch drives when application status changes
    fetchAllJobDrives();
  });

  // Handle real-time modal updates
  useModalUpdates(selectedDrive?._id, (updatedDrive, action) => {
    if (action === 'updated') {
      // Update the selected drive data in the modal
      setSelectedDrive(updatedDrive);
    }
  });

  // Handle real-time round updates
  useRoundUpdates((data) => {
    const { action, jobDrive } = data;
    
    // If modal is open for this drive, refresh the selected drive data
    if (selectedDrive && jobDrive && (jobDrive._id === selectedDrive._id || jobDrive.id === selectedDrive._id)) {
      setSelectedDrive(jobDrive);
    }
    
    // If round management modal is open, refresh that too
    if (selectedDriveForRounds && jobDrive && (jobDrive._id === selectedDriveForRounds._id || jobDrive.id === selectedDriveForRounds._id)) {
      setSelectedDriveForRounds(jobDrive);
    }
    
    // Refresh the drives list
    fetchAllJobDrives();
  });

  // Add these helper functions at the top of the component
  const isDriveCreator = (drive) => {
    const isCreator = drive.createdBy?._id === user?.id;
    console.log("=== CREATOR CHECK ===");
    console.log("Drive:", drive.companyName);
    console.log("Drive creator ID:", drive.createdBy?._id);
    console.log("Current user ID:", user?.id);
    console.log("Is creator:", isCreator);
    return isCreator;
  };

  const canManageDrive = (drive) => {
    // If no createdBy info, nobody can manage
    if (!drive.createdBy) {
      console.log("❌ No creator info - no management access");
      return false;
    }

    // Check if user created the drive
    const isCreator = isDriveCreator(drive);

    // For PRs - also check department access
    if (user?.role === "placement_representative" || user?.role === "pr") {
      const userDept = normalizeDepartment(user.profile?.department);
      const creatorDept = normalizeDepartment(
        drive.createdBy?.profile?.department
      );

      console.log("=== MANAGE ACCESS CHECK ===");
      console.log("Drive:", drive.companyName);
      console.log("User:", user.email);
      console.log("User Dept (normalized):", userDept);
      console.log("Creator:", drive.createdBy.email);
      console.log("Creator Dept (normalized):", creatorDept);
      console.log("Is creator:", isCreator);

      // Allow if same department OR if user created the drive
      if (isCreator || (userDept && creatorDept && userDept === creatorDept)) {
        console.log(
          "✅ Management access granted - same department or creator"
        );
        return true;
      } else {
        console.log("❌ Different department and not creator - access denied");
        return false;
      }
    }

    // For POs - they can manage everything
    if (user?.role === "po" || user?.role === "placement_officer") {
      return true;
    }

    return isCreator;
  };

  const isViewOnlyPR = (drive) => {
    return (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      !canManageDrive(drive)
    );
  };

  // Function to check if applications are still open (for application deadline)
  const isApplicationDeadlinePassed = (drive) => {
    // If there's a deadline, use that; otherwise use drive date
    const checkDate = drive.deadline || drive.date;
    if (!checkDate) return false;

    const deadlineDateTime = new Date(checkDate);

    // If drive has a specific time, use it; otherwise assume end of day
    if (drive.time && drive.deadline) {
      const [hours, minutes] = drive.time.split(":");
      deadlineDateTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
    } else {
      // If no time specified, consider applications open until end of deadline day
      deadlineDateTime.setHours(23, 59, 59, 999);
    }

    const currentDateTime = new Date();
    return currentDateTime > deadlineDateTime;
  };

  // Function to check if drive has ended (for filtering purposes)
  const isDriveEnded = (drive) => {
    if (!drive.date) return false;

    const driveDate = new Date(drive.date);
    const currentDate = new Date();

    // If drive has time, use it for comparison
    if (drive.time) {
      const [hours, minutes] = drive.time.split(":").map(Number);
      driveDate.setHours(hours, minutes, 0, 0);
      return currentDate > driveDate;
    } else {
      // If no time specified, consider drive ended at end of day
      driveDate.setHours(23, 59, 59, 999);
      return currentDate > driveDate;
    }
  };

  const handleViewPlacedStudents = async (drive) => {
    try {
      const driveEnded = isDriveEnded(drive);
      
      // Only try to get students from selection rounds if drive has ended
      if (driveEnded && drive.selectionRounds && drive.selectionRounds.length > 0) {
        const token = localStorage.getItem("token");
        const response = await fetch(
          `http://localhost:5000/api/job-drives/${drive._id}/last-round-students`,
          {
            method: "GET",
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
          }
        );

        if (response.ok) {
          const data = await response.json();
          if (data.students && data.students.length > 0) {
            // Create a drive object with the selection round students for modal display
            const driveWithRoundStudents = {
              ...drive,
              placedStudents: data.students, // Use students from final round
            };
            setSelectedDriveForView(driveWithRoundStudents);
            setShowPlacedStudentsViewModal(true);
            return;
          }
        }
      }

      // Always allow viewing manual placed students (regardless of drive end date)
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
        return;
      }

      // If no placed students found from either source
      toast.error("No placed students found for this drive");
    } catch (error) {
      console.error("Error fetching placed students:", error);
      // Fallback to showing manual placed students if API call fails
      if (drive.placedStudents && drive.placedStudents.length > 0) {
        setSelectedDriveForView(drive);
        setShowPlacedStudentsViewModal(true);
      } else {
        toast.error("Failed to fetch placed students");
      }
    }
  };

  useEffect(() => {
    // Wait for auth context to load before checking user
    if (user === null) {
      // Still loading auth state, don't redirect yet
      return;
    }

    // Allow both placement_representative and placement_officer
    if (
      !user ||
      (user.role !== "placement_representative" &&
        user.role !== "placement_officer" &&
        user.role !== "po")
    ) {
      navigate("/login");
      return;
    }
    fetchAllJobDrives();
  }, [user, navigate]);

  const fetchAllJobDrives = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem("token");
      const response = await axios.get("http://localhost:5000/api/job-drives", {
        headers: { Authorization: `Bearer ${token}` },
      });

      console.log("=== API RESPONSE DEBUG ===");
      console.log("Full response:", response.data);
      console.log("Job drives:", response.data.jobDrives);

      // Debug each drive's creator info
      response.data.jobDrives.forEach((drive, index) => {
        console.log(`Drive ${index + 1} (${drive.companyName}):`, {
          createdBy: drive.createdBy,
          createdById: drive.createdBy?._id,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      setDrives(response.data.jobDrives || []);
    } catch (error) {
      console.error("Error fetching job drives:", error);
      toast.error("Failed to fetch job drives");
    } finally {
      setLoading(false);
    }
  };

  // Add this useEffect to debug the data
  useEffect(() => {
    if (drives.length > 0) {
      console.log("=== DRIVES DEBUG ===");
      drives.forEach((drive, index) => {
        console.log(`Drive ${index + 1}:`, {
          company: drive.companyName,
          createdBy: drive.createdBy,
          createdByProfile: drive.createdBy?.profile,
          createdByDept: drive.createdBy?.profile?.department,
        });
      });

      console.log("Current user:", {
        role: user?.role,
        department: user?.profile?.department,
        profile: user?.profile,
      });
    }
  }, [drives, user]);

  const handleDeleteDrive = async (driveId) => {
    // Get drive details for the confirmation
    const drive = drives.find((d) => d._id === driveId);
    const driveName = drive
      ? `${drive.companyName} - ${drive.role}`
      : "this job drive";

    // Set up deletion target and show modal
    setDeleteTarget({
      id: driveId,
      name: driveName,
      drive: drive,
    });
    setShowDeleteModal(true);
  };

  const confirmDeleteDrive = async () => {
    if (!deleteTarget) return;

    // For PRs, validate reason
    if (
      (user?.role === "placement_representative" || user?.role === "pr") &&
      (!deleteReason || deleteReason.trim() === "")
    ) {
      toast.error("Reason is required for deletion request");
      return;
    }

    try {
      const token = localStorage.getItem("token");

      // Use the new deletion request API
      await axios.post(
        "http://localhost:5000/api/deletion-requests/request",
        {
          jobDriveId: deleteTarget.id,
          reason: deleteReason || "Administrative deletion",
        },
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );

      if (user?.role === "po" || user?.role === "placement_officer") {
        toast.success("Job drive deleted successfully");
        setDrives(drives.filter((drive) => drive._id !== deleteTarget.id));
      } else {
        toast.success(
          "Deletion request submitted successfully. Awaiting PO approval."
        );
        // Don't remove from list as it's pending approval
      }

      // Close modal and reset state
      setShowDeleteModal(false);
      setDeleteTarget(null);
      setDeleteReason("");
    } catch (error) {
      console.error("Delete error:", error);
      if (error.response?.data?.message) {
        toast.error(error.response.data.message);
      } else {
        toast.error("Failed to process deletion request");
      }
    }
  };

  const cancelDelete = () => {
    setShowDeleteModal(false);
    setDeleteTarget(null);
    setDeleteReason("");
  };

  const handleEditDrive = (driveId) => {
    navigate(`/pr/edit-job/${driveId}?returnTo=/all-job-drives`);
  };

  const handleViewDetails = (drive) => {
    console.log("=== DRIVE DETAILS DEBUG ===");
    console.log("Full drive object:", JSON.stringify(drive, null, 2));
    console.log("Eligibility object:", drive.eligibility);
    console.log("Min CGPA field:", drive.eligibility?.minCGPA);
    console.log("CGPA field:", drive.eligibility?.cgpa);
    console.log("Test Details:", drive.testDetails);
    console.log("Interview Process:", drive.interviewProcess);
    console.log("Bond:", drive.bond);

    setSelectedDrive(drive);
    setShowModal(true);
  };

  const closeModal = () => {
    setShowModal(false);
    setSelectedDrive(null);
  };

  const getFilteredDrives = () => {
    console.log("=== ALL JOB DRIVES FILTERING ===");
    console.log("Total drives:", drives.length);
    console.log("Current filter:", filter);
    console.log("User role:", user?.role);

    return drives.filter((drive) => {
      const driveEnded = isDriveEnded(drive);
      console.log(
        `Drive ${drive.companyName}: ended=${driveEnded}, date=${drive.date}, time=${drive.time}`
      );

      if (filter === "upcoming") {
        return !driveEnded; // Not ended yet
      } else if (filter === "past") {
        return driveEnded; // Drive has ended
      }
      return true; // 'all' filter
    });
  };

  const handleEditStudent = (student, index) => {
    setEditingStudent(index);
    setEditStudentData({
      name: student.name,
      rollNumber: student.rollNumber,
      department: student.department || "",
      email: student.email,
      mobileNumber: student.mobileNumber || "",
    });
  };

  const handleSaveEdit = async (index) => {
    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/update-placed-student`,
        {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({
            index: index,
            studentData: editStudentData,
          }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student updated successfully!");
        setEditingStudent(null);

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to update student");
      }
    } catch (error) {
      console.error("Error updating student:", error);
      toast.error("Error updating student");
    }
  };

  const handleDeleteStudent = async (index) => {
    setDeleteStudentIndex(index);
    setShowDeleteStudentModal(true);
  };

  const confirmDeleteStudent = async () => {
    if (deleteStudentIndex === null) return;

    try {
      const response = await fetch(
        `http://localhost:5000/api/job-drives/${selectedDriveForView._id}/delete-placed-student`,
        {
          method: "DELETE",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({ index: deleteStudentIndex }),
        }
      );

      if (response.ok) {
        const result = await response.json();
        toast.success("Student deleted successfully!");

        // Update the local state immediately
        setSelectedDriveForView((prev) => ({
          ...prev,
          placedStudents: result.placedStudents,
        }));

        // Also refresh the main drives list
        await fetchAllJobDrives();
      } else {
        const errorData = await response.json();
        toast.error(errorData.message || "Failed to delete student");
      }
    } catch (error) {
      console.error("Error deleting student:", error);
      toast.error("Error deleting student");
    } finally {
      setShowDeleteStudentModal(false);
      setDeleteStudentIndex(null);
    }
  };

  const cancelDeleteStudent = () => {
    setShowDeleteStudentModal(false);
    setDeleteStudentIndex(null);
  };

  const downloadCSV = () => {
    if (!selectedDriveForView?.placedStudents?.length) {
      toast.error("No data to download");
      return;
    }

    const headers = [
      "S.No",
      "Name",
      "Roll Number",
      "Department",
      "Email",
      "Mobile",
      "Added On",
    ];
    const csvContent = [
      headers.join(","),
      ...selectedDriveForView.placedStudents.map((student, index) =>
        [
          index + 1,
          `"${student.name}"`,
          `"${student.rollNumber}"`,
          `"${student.department || "N/A"}"`,
          `"${student.email}"`,
          `"${student.mobileNumber || "N/A"}"`,
          `"${
            student.addedAt
              ? new Date(student.addedAt).toLocaleDateString()
              : "N/A"
          }"`,
        ].join(",")
      ),
    ].join("\n");

    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute(
      "download",
      `${selectedDriveForView.companyName}_placed_students.csv`
    );
    link.style.visibility = "hidden";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const handleManageRounds = (drive, roundIndex) => {
    // For same department PRs - full management access
    setSelectedJobForRounds(drive);
    setSelectedRoundIndex(roundIndex);
    setShowRoundModal(true);
  };

  const handleViewRoundStudents = (drive, round, roundIndex) => {
    console.log("=== VIEW ROUND STUDENTS (PO) ===");
    console.log("Drive:", drive.companyName);
    console.log("Round:", round.name || `Round ${roundIndex + 1}`);
    console.log("Selected Students:", round.selectedStudents);

    setSelectedJobForRoundView(drive);
    setSelectedRound(round);
    setSelectedRoundIndex(roundIndex);
    setShowRoundStudentsModal(true);
  };

  const closeRoundModal = () => {
    setShowRoundModal(false);
    setSelectedJobForRounds(null);
    setSelectedRoundIndex(null);
    fetchAllJobDrives(); // Refresh the drives data
  };

  const closeRoundStudentsModal = () => {
    setShowRoundStudentsModal(false);
    setSelectedRound(null);
    setSelectedRoundIndex(null);
    setSelectedJobForRoundView(null);
  };

  // Add these handler functions after existing handlers
  const handleManageRoundsClick = (drive) => {
    setSelectedDriveForRounds(drive);
    setShowManageRoundsModal(true);
  };

  const handleRoundSelect = async (round, roundIndex) => {
    setSelectedRoundForManagement(round);
    setSelectedRoundIndex(roundIndex);
    setLoadingApplicants(true);

    try {
      const token = localStorage.getItem("token");
      let studentsToShow = [];

      if (roundIndex === 0) {
        // First round - show all applicants
        const response = await axios.get(
          `http://localhost:5000/api/job-drives/${selectedDriveForRounds._id}/students`,
          {
            headers: { Authorization: `Bearer ${token}` },
          }
        );
        console.log("First round response:", response.data);
        studentsToShow = response.data.students || [];
      } else {
        // Subsequent rounds - show selected students from previous round
        const previousRound =
          selectedDriveForRounds.selectionRounds[roundIndex - 1];
        console.log("Previous round:", previousRound);

        if (
          previousRound &&
          previousRound.selectedStudents &&
          previousRound.selectedStudents.length > 0
        ) {
          const response = await axios.post(
            `http://localhost:5000/api/job-drives/${selectedDriveForRounds._id}/get-students-by-ids`,
            { studentIds: previousRound.selectedStudents },
            { headers: { Authorization: `Bearer ${token}` } }
          );
          console.log("Subsequent round response:", response.data);
          studentsToShow = response.data.students || [];
        }
      }

      console.log("Students to show:", studentsToShow);
      // Filter out any null or undefined students
      const validStudents = studentsToShow.filter(
        (student) => student && student._id
      );
      console.log("Valid students:", validStudents);
      setRoundApplicants(validStudents);
      setSelectedStudentsForRound(round.selectedStudents || []);
    } catch (error) {
      console.error("Error fetching applicants:", error);
      toast.error("Failed to fetch applicants");
      setRoundApplicants([]);
    } finally {
      setLoadingApplicants(false);
    }
  };

  const handleStudentSelection = (studentId) => {
    setSelectedStudentsForRound((prev) => {
      if (prev.includes(studentId)) {
        return prev.filter((id) => id !== studentId);
      } else {
        return [...prev, studentId];
      }
    });
  };

  const handleSaveSelectedStudents = async () => {
    try {
      const token = localStorage.getItem("token");
      await axios.post(
        `http://localhost:5000/api/job-drives/${selectedDriveForRounds._id}/rounds/${selectedRoundIndex}/select-students`,
        { studentIds: selectedStudentsForRound },
        {
          headers: { Authorization: `Bearer ${token}` },
        }
      );

      toast.success("Students selected successfully");
      setSelectedRoundForManagement(null);
      setSelectedRoundIndex(null);
      fetchAllJobDrives(); // Refresh data
    } catch (error) {
      console.error("Error saving selected students:", error);
      toast.error("Failed to save selected students");
    }
  };

  const closeManageRoundsModal = () => {
    setShowManageRoundsModal(false);
    setSelectedDriveForRounds(null);
    setSelectedRoundForManagement(null);
    setSelectedRoundIndex(null);
    setRoundApplicants([]);
    setSelectedStudentsForRound([]);
  };

  // Modal component - Enhanced with all job details
  const DriveModal = ({ drive, onClose }) => {
    if (!drive) return null;

    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div className="bg-white rounded-lg w-full max-w-6xl max-h-[90vh] overflow-y-auto">
          {/* Header */}
          <div className="sticky top-0 bg-white border-b border-gray-200 px-6 py-4 flex justify-between items-center">
            <div>
              <h2 className="text-2xl font-bold text-gray-900">
                {drive.companyName}
              </h2>
              <p className="text-lg text-gray-600">{drive.role}</p>
            </div>
            <button
              onClick={onClose}
              className="text-gray-500 hover:text-gray-700 text-2xl font-bold"
            >
              ×
            </button>
          </div>

          {/* Content - Two Column Layout */}
          <div className="p-6">
            <div className="grid grid-cols-2 gap-8">
              {/* Left Column */}
              <div className="space-y-6 min-w-0">
                {/* Company Details */}
                <div>
                  <h3 className="text-lg font-semibold text-gray-900 mb-3">
                    Company Details
                  </h3>
                  <div className="space-y-2 text-sm">
                    <div className="flex flex-wrap">
                      <span className="font-medium text-gray-700 w-24 flex-shrink-0">
                        Name:
                      </span>
                      <span className="text-gray-600 break-words flex-1">
                        {drive.companyName}
                      </span>
                    </div>
                    {drive.companyWebsite && (
                      <div className="flex flex-wrap">
                        <span className="font-medium text-gray-700 w-24 flex-shrink-0">
                          Website:
                        </span>
                        <a
                          href={drive.companyWebsite}
                          target="_blank"
                          rel="noopener noreferrer"
                          className="text-blue-600 hover:underline break-all flex-1"
                        >
                          {drive.companyWebsite}
                        </a>
                      </div>
                    )}
                    {drive.companyDescription && (
                      <div>
                        <span className="font-medium text-gray-700">
                          Description:
                        </span>
                        <p className="text-gray-600 mt-1 text-justify break-words">
                          {drive.companyDescription}
                        </p>
                      </div>
                    )}
                  </div>
                </div>

                {/* Job Information */}
                <div>
                  <h3 className="text-lg font-semibold text-gray-900 mb-3">
                    Job Information
                  </h3>
                  <div className="space-y-2 text-sm">
                    <div className="flex flex-wrap">
                      <span className="font-medium text-gray-700 w-24 flex-shrink-0">
                        Type:
                      </span>
                      <span className="text-gray-600 break-words">
                        {drive.type || drive.jobType || "Full Time"}
                      </span>
                    </div>
                    <div className="flex flex-wrap">
                      <span className="font-medium text-gray-700 w-24 flex-shrink-0">
                        Location:
                      </span>
                      <span className="text-gray-600 break-words flex-1">
                        {drive.location ||
                          drive.locations?.join(", ") ||
                          "Not specified"}
                      </span>
                    </div>
                    <div className="flex flex-wrap">
                      <span className="font-medium text-gray-700 w-24 flex-shrink-0">
                        CTC:
                      </span>
                      <span className="text-gray-600">
                        ₹{drive.ctc || "Not disclosed"} LPA
                      </span>
                    </div>
                    <div className="flex flex-wrap">
                      <span className="font-medium text-gray-700 w-24 flex-shrink-0">
                        Date:
                      </span>
                      <span className="text-gray-600">
                        {new Date(drive.date).toLocaleDateString()}
                      </span>
                    </div>
                    {drive.time && (
                      <div className="flex flex-wrap">
                        <span className="font-medium text-gray-700 w-24 flex-shrink-0">
                          Time:
                        </span>
                        <span className="text-gray-600">{drive.time}</span>
                      </div>
                    )}
                    <div className="flex flex-wrap">
                      <span className="font-medium text-gray-700 w-24 flex-shrink-0">
                        Deadline:
                      </span>
                      <span className="text-gray-600">
                        {drive.deadline
                          ? new Date(drive.deadline).toLocaleDateString()
                          : "Not specified"}
                      </span>
                    </div>
                  </div>
                </div>

                {/* CTC Breakdown */}
                {drive.ctcBreakdown &&
                  (drive.ctcBreakdown.baseSalary ||
                    drive.ctcBreakdown.variablePay ||
                    drive.ctcBreakdown.joiningBonus ||
                    drive.ctcBreakdown.otherBenefits) && (
                    <div>
                      <h3 className="text-lg font-semibold text-gray-900 mb-3">
                        CTC Breakdown
                      </h3>
                      <div className="space-y-2 text-sm">
                        {drive.ctcBreakdown.baseSalary && (
                          <div className="flex flex-wrap">
                            <span className="font-medium text-gray-700 w-32 flex-shrink-0">
                              Base Salary:
                            </span>
                            <span className="text-gray-600">
                              ₹{drive.ctcBreakdown.baseSalary} LPA
                            </span>
                          </div>
                        )}
                        {drive.ctcBreakdown.variablePay && (
                          <div className="flex flex-wrap">
                            <span className="font-medium text-gray-700 w-32 flex-shrink-0">
                              Variable Pay:
                            </span>
                            <span className="text-gray-600">
                              ₹{drive.ctcBreakdown.variablePay} LPA
                            </span>
                          </div>
                        )}
                        {drive.ctcBreakdown.joiningBonus && (
                          <div className="flex flex-wrap">
                            <span className="font-medium text-gray-700 w-32 flex-shrink-0">
                              Joining Bonus:
                            </span>
                            <span className="text-gray-600">
                              ₹{drive.ctcBreakdown.joiningBonus} LPA
                            </span>
                          </div>
                        )}
                        {drive.ctcBreakdown.otherBenefits && (
                          <div>
                            <span className="font-medium text-gray-700">
                              Other Benefits:
                            </span>
                            <p className="text-gray-600 mt-1 text-justify break-words">
                              {drive.ctcBreakdown.otherBenefits}
                            </p>
                          </div>
                        )}
                      </div>
                    </div>
                  )}

                {/* Drive Details */}
                <div>
                  <h3 className="text-lg font-semibold text-gray-900 mb-3">
                    Drive Details
                  </h3>
                  <div className="space-y-2 text-sm">
                    <div className="flex flex-wrap">
                      <span className="font-medium text-gray-700 w-24 flex-shrink-0">
                        Mode:
                      </span>
                      <span className="text-gray-600">
                        {drive.driveMode || "On Campus"}
                      </span>
                    </div>
                    {drive.venue && (
                      <div className="flex flex-wrap">
                        <span className="font-medium text-gray-700 w-24 flex-shrink-0">
                          Venue:
                        </span>
                        <span className="text-gray-600 break-words flex-1">
                          {drive.venue}
                        </span>
                      </div>
                    )}
                    <div className="flex flex-wrap">
                      <span className="font-medium text-gray-700 w-24 flex-shrink-0">
                        Applications:
                      </span>
                      <span className="text-gray-600">
                        {drive.applications?.length || 0}
                      </span>
                    </div>
                    {drive.placedStudents &&
                      drive.placedStudents.length > 0 && (
                        <div className="flex flex-wrap">
                          <span className="font-medium text-gray-700 w-24 flex-shrink-0">
                            Placed:
                          </span>
                          <span className="text-gray-600">
                            {drive.placedStudents.length}
                          </span>
                        </div>
                      )}
                  </div>
                </div>

                {/* Description */}
                <div>
                  <h3 className="text-lg font-semibold text-gray-900 mb-3">
                    Description
                  </h3>
                  <p className="text-sm text-gray-600 text-justify leading-relaxed break-words">
                    {drive.description || "No description provided"}
                  </p>
                </div>
              </div>

              {/* Right Column */}
              <div className="space-y-6 min-w-0">
                {/* Eligibility Criteria */}
                <div>
                  <h3 className="text-lg font-semibold text-gray-900 mb-3">
                    Eligibility Criteria
                  </h3>
                  <div className="space-y-2 text-sm">
                    <div className="flex flex-wrap">
                      <span className="font-medium text-gray-700 w-32 flex-shrink-0">
                        Min CGPA:
                      </span>
                      <span className="text-gray-600">
                        {drive.eligibility?.minCGPA ||
                          drive.eligibility?.cgpa ||
                          "Not specified"}
                      </span>
                    </div>
                    <div className="flex flex-wrap">
                      <span className="font-medium text-gray-700 w-32 flex-shrink-0">
                        Max Backlogs:
                      </span>
                      <span className="text-gray-600">
                        {drive.eligibility?.maxBacklogs !== undefined
                          ? drive.eligibility.maxBacklogs
                          : "Not specified"}
                      </span>
                    </div>
                    <div>
                      <span className="font-medium text-gray-700">
                        Departments:
                      </span>
                      <p className="text-gray-600 mt-1 break-words">
                        {drive.eligibility?.allowedDepartments?.length > 0 ||
                        drive.eligibility?.departments?.length > 0
                          ? (
                              drive.eligibility?.allowedDepartments ||
                              drive.eligibility?.departments
                            ).join(", ")
                          : "All departments allowed"}
                      </p>
                    </div>
                    <div>
                      <span className="font-medium text-gray-700">
                        Batches:
                      </span>
                      <p className="text-gray-600 mt-1">
                        {drive.eligibility?.allowedBatches?.length > 0 ||
                        drive.eligibility?.batches?.length > 0
                          ? (
                              drive.eligibility?.allowedBatches ||
                              drive.eligibility?.batches
                            ).join(", ")
                          : "All batches allowed"}
                      </p>
                    </div>
                  </div>
                </div>

                {/* Requirements */}
                {drive.requirements && (
                  <div>
                    <h3 className="text-lg font-semibold text-gray-900 mb-3">
                      Requirements
                    </h3>
                    <p className="text-sm text-gray-600 text-justify break-words">
                      {drive.requirements}
                    </p>
                  </div>
                )}

                {/* Skills */}
                {drive.skills && drive.skills.length > 0 && (
                  <div>
                    <h3 className="text-lg font-semibold text-gray-900 mb-3">
                      Required Skills
                    </h3>
                    <div className="flex flex-wrap gap-2">
                      {(Array.isArray(drive.skills)
                        ? drive.skills
                        : drive.skills.split(",")
                      ).map((skill, index) => (
                        <span
                          key={index}
                          className="px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-sm"
                        >
                          {skill.trim()}
                        </span>
                      ))}
                    </div>
                  </div>
                )}

                {/* Selection Process - Always show this section */}
                <div>
                  <h3 className="text-lg font-semibold text-gray-900 mb-3">
                    Selection Process
                  </h3>

                  {/* Rounds */}
                  <div className="mb-3">
                    <span className="font-medium text-gray-700 text-sm">
                      Rounds:
                    </span>
                    <div className="mt-1">
                      {drive.selectionRounds &&
                      Array.isArray(drive.selectionRounds) &&
                      drive.selectionRounds.length > 0 ? (
                        drive.selectionRounds.map((round, index) => (
                          <div
                            key={index}
                            className="text-sm text-gray-600 break-words"
                          >
                            {index + 1}.{" "}
                            {round.name ||
                              round.details ||
                              `Round ${index + 1}`}
                          </div>
                        ))
                      ) : drive.rounds && drive.rounds.length > 0 ? (
                        (Array.isArray(drive.rounds)
                          ? drive.rounds
                          : drive.rounds.split(",")
                        ).map((round, index) => (
                          <div
                            key={index}
                            className="text-sm text-gray-600 break-words"
                          >
                            {index + 1}.{" "}
                            {typeof round === "string"
                              ? round.trim()
                              : round.name || `Round ${index + 1}`}
                          </div>
                        ))
                      ) : (
                        <div className="text-sm text-gray-600">
                          Not specified
                        </div>
                      )}
                    </div>
                  </div>

                  {/* Test Details */}
                  <div className="mb-3">
                    <span className="font-medium text-gray-700 text-sm">
                      Test Details:
                    </span>
                    <p className="text-sm text-gray-600 mt-1 text-justify break-words">
                      {drive.testDetails || "Not specified"}
                    </p>
                  </div>

                  {/* Interview Process */}
                  <div>
                    <span className="font-medium text-gray-700 text-sm">
                      Interview Process:
                    </span>
                    <p className="text-sm text-gray-600 mt-1 text-justify break-words">
                      {drive.interviewProcess || "Not specified"}
                    </p>
                  </div>
                </div>

                {/* Bond Information - Always show this section */}
                <div>
                  <h3 className="text-lg font-semibold text-gray-900 mb-3">
                    Bond Information
                  </h3>
                  <div className="space-y-2 text-sm">
                    <div>
                      <span className="font-medium text-gray-700">
                        Details:
                      </span>
                      <p className="text-gray-600 mt-1 text-justify break-words">
                        {drive.bond || "No bond required"}
                      </p>
                    </div>
                    {(drive.bondDetails?.amount ||
                      drive.bondDetails?.duration) && (
                      <>
                        {drive.bondDetails?.amount && (
                          <div className="flex flex-wrap">
                            <span className="font-medium text-gray-700 w-24 flex-shrink-0">
                              Amount:
                            </span>
                            <span className="text-gray-600">
                              ₹{drive.bondDetails.amount}
                            </span>
                          </div>
                        )}
                        {drive.bondDetails?.duration && (
                          <div className="flex flex-wrap">
                            <span className="font-medium text-gray-700 w-24 flex-shrink-0">
                              Duration:
                            </span>
                            <span className="text-gray-600 break-words">
                              {drive.bondDetails.duration}
                            </span>
                          </div>
                        )}
                      </>
                    )}
                  </div>
                </div>

                {/* Job Flags */}
                {(drive.isDreamJob || drive.unplacedOnly) && (
                  <div>
                    <h3 className="text-lg font-semibold text-gray-900 mb-3">
                      Job Flags
                    </h3>
                    <div className="flex flex-wrap gap-2">
                      {drive.isDreamJob && (
                        <span className="px-3 py-1 bg-yellow-100 text-yellow-800 rounded-full text-sm font-medium">
                          ⭐ Dream Job
                        </span>
                      )}
                      {drive.unplacedOnly && (
                        <span className="px-3 py-1 bg-orange-100 text-orange-800 rounded-full text-sm font-medium">
                          👥 Unplaced Only
                        </span>
                      )}
                    </div>
                  </div>
                )}

                {/* Recruiter Contact */}
                {drive.recruiterContact &&
                  (drive.recruiterContact.name ||
                    drive.recruiterContact.email ||
                    drive.recruiterContact.phone) && (
                    <div>
                      <h3 className="text-lg font-semibold text-gray-900 mb-3">
                        Recruiter Contact
                      </h3>
                      <div className="space-y-2 text-sm">
                        {drive.recruiterContact.name && (
                          <div className="flex flex-wrap">
                            <span className="font-medium text-gray-700 w-20 flex-shrink-0">
                              Name:
                            </span>
                            <span className="text-gray-600 break-words">
                              {drive.recruiterContact.name}
                            </span>
                          </div>
                        )}
                        {drive.recruiterContact.email && (
                          <div className="flex flex-wrap">
                            <span className="font-medium text-gray-700 w-20 flex-shrink-0">
                              Email:
                            </span>
                            <a
                              href={`mailto:${drive.recruiterContact.email}`}
                              className="text-blue-600 hover:underline break-all"
                            >
                              {drive.recruiterContact.email}
                            </a>
                          </div>
                        )}
                        {drive.recruiterContact.phone && (
                          <div className="flex flex-wrap">
                            <span className="font-medium text-gray-700 w-20 flex-shrink-0">
                              Phone:
                            </span>
                            <a
                              href={`tel:${drive.recruiterContact.phone}`}
                              className="text-blue-600 hover:underline"
                            >
                              {drive.recruiterContact.phone}
                            </a>
                          </div>
                        )}
                      </div>
                    </div>
                  )}
              </div>
            </div>
          </div>

          {/* Footer */}
          <div className="sticky bottom-0 bg-gray-50 px-6 py-4 border-t border-gray-200">
            <div className="flex justify-between items-center">
              <div className="text-sm text-gray-500">
                <p>
                  Created by:{" "}
                  {drive.createdBy?.profile?.name ||
                    drive.createdBy?.name ||
                    drive.createdBy?.email ||
                    (drive.createdBy ? "Unknown User" : "System Generated")}
                </p>
                <p>
                  Created on:{" "}
                  {drive.createdAt
                    ? new Date(drive.createdAt).toLocaleDateString()
                    : drive.date
                    ? new Date(drive.date).toLocaleDateString()
                    : "Unknown"}
                </p>
              </div>
              <button
                onClick={onClose}
                className="px-6 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors"
              >
                Close
              </button>
            </div>
          </div>
        </div>
      </div>
    );
  };

  const filteredDrives = getFilteredDrives();

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-lg">Loading...</div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50 py-8">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        {/* Header with department info for PRs */}
        <div className="flex justify-between items-center mb-6">
          <div>
            <h1 className="text-3xl font-bold text-gray-900">All Job Drives</h1>
            {user?.role === "placement_representative" && (
              <p className="text-gray-600 mt-1">
                Showing all job drives across all departments
              </p>
            )}
            {(user?.role === "po" || user?.role === "placement_officer") && (
              <p className="text-gray-600 mt-1">
                Showing all job drives (Placement Officer View)
              </p>
            )}
          </div>
          <div className="flex flex-wrap">
            <button
              onClick={() => navigate("/pr-create-job")}
              className="bg-blue-600 text-white px-4 py-2 mr-2 rounded-lg hover:bg-blue-700 transition-colors"
            >
              Create Job Drive
            </button>
            <button
              onClick={() => navigate("/pr-dashboard")}
              className="bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 transition-colors"
            >
              Back to Dashboard
            </button>
          </div>
        </div>

        {/* Filter Buttons - use same logic as JobDrives.js */}
        <div className="mb-6 flex flex-wrap gap-2">
          {["all", "upcoming", "past"].map((filterType) => (
            <button
              key={filterType}
              onClick={() => setFilter(filterType)}
              className={`px-4 py-2 rounded-lg font-medium capitalize transition-colors ${
                filter === filterType
                  ? "bg-blue-600 text-white"
                  : "bg-white text-gray-700 hover:bg-gray-50 border border-gray-300"
              }`}
            >
              {filterType} (
              {
                drives.filter((drive) => {
                  const driveEnded = isDriveEnded(drive);

                  if (filterType === "upcoming") return !driveEnded;
                  if (filterType === "past") return driveEnded;
                  return true;
                }).length
              }
              )
            </button>
          ))}
        </div>

        {/* Drives List */}
        {filteredDrives.length === 0 ? (
          <div className="text-center py-8">
            <p className="text-gray-500">
              No job drives found for "{filter}" filter
            </p>
          </div>
        ) : (
          <div className="grid gap-6">
            {filteredDrives.map((drive) => {
              const driveEnded = isDriveEnded(drive);
              const hasSelectionRounds =
                drive.selectionRounds &&
                Array.isArray(drive.selectionRounds) &&
                drive.selectionRounds.length > 0;
              const canManage = canManageDrive(drive);
              const isCreator = isDriveCreator(drive);

              return (
                <div key={drive._id} className="bg-white p-6 rounded-lg shadow">
                  {/* Header with buttons */}
                  <div className="flex justify-between items-start mb-4">
                    <div className="flex-1">
                      <div className="flex items-center space-x-3 mb-2">
                        <h3 className="text-xl font-semibold text-gray-900">
                          {drive.companyName}
                        </h3>
                        <span
                          className={`px-2 py-1 rounded-full text-sm ${
                            !driveEnded
                              ? "bg-blue-100 text-blue-800"
                              : "bg-gray-100 text-gray-800"
                          }`}
                        >
                          {!driveEnded ? "Upcoming" : "Ended"}
                        </span>
                        {hasSelectionRounds && (
                          <span className="px-2 py-1 rounded-full text-sm bg-purple-100 text-purple-800">
                            {drive.selectionRounds.length} Rounds
                          </span>
                        )}
                        {!drive.createdBy && (
                          <span className="px-2 py-1 rounded-full text-sm bg-red-100 text-red-800">
                            Missing Creator Info
                          </span>
                        )}
                      </div>

                      <p className="text-gray-600 mb-3">{drive.role}</p>

                      <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm text-gray-500">
                        <div>
                          <span className="font-medium">Location:</span>{" "}
                          {drive.displayLocation ||
                            drive.location ||
                            (drive.locations && drive.locations.length > 0
                              ? drive.locations.join(", ")
                              : "Not specified")}
                        </div>
                        <div>
                          <span className="font-medium">Type:</span>{" "}
                          {drive.displayType ||
                            drive.type ||
                            drive.jobType ||
                            "Not specified"}
                        </div>
                        <div>
                          <span className="font-medium">CTC:</span>
                          {drive.ctc ? `₹${drive.ctc} LPA` : "Not specified"}
                        </div>
                        <div>
                          <span className="font-medium">Date:</span>{" "}
                          {drive.date
                            ? new Date(drive.date).toLocaleDateString()
                            : "Not specified"}
                          {drive.time && (
                            <span className="ml-1">at {drive.time}</span>
                          )}
                        </div>
                      </div>
                    </div>

                    <div className="flex items-center space-x-2 ml-4">
                      <button
                        onClick={() => handleViewDetails(drive)}
                        className="px-4 py-2 bg-blue-100 text-blue-700 hover:bg-blue-200 rounded-lg font-medium text-sm"
                      >
                        View
                      </button>

                      {/* Add Manage Rounds button in the action buttons section (after View Details button) */}
                      {hasSelectionRounds && canManage && (
                        <button
                          onClick={() => handleManageRoundsClick(drive)}
                          className="px-4 py-2 bg-purple-100 text-purple-700 hover:bg-purple-200 rounded-lg font-medium text-sm"
                        >
                          Manage Rounds
                        </button>
                      )}

                      {/* Everyone can View Placed Students if they exist */}
                      {driveEnded &&
                        getPlacedStudentsCount(drive) > 0 && (
                          <button
                            onClick={() => handleViewPlacedStudents(drive)}
                            className="px-4 py-2 bg-purple-100 text-purple-700 hover:bg-purple-200 rounded-lg font-medium text-sm"
                          >
                            Placed Students ({getPlacedStudentsCount(drive)})
                          </button>
                        )}

                      {/* STRICT: Only creator can Edit/Delete */}
                      {isDriveCreator(drive) && (
                        <>
                          <button
                            onClick={() => handleEditDrive(drive._id)}
                            className="px-4 py-2 bg-yellow-100 text-yellow-700 hover:bg-yellow-200 rounded-lg font-medium text-sm"
                          >
                            Edit
                          </button>
                          <button
                            onClick={() => handleDeleteDrive(drive._id)}
                            className="px-4 py-2 bg-red-100 text-red-700 hover:bg-red-200 rounded-lg font-medium text-sm"
                          >
                            Delete
                          </button>
                        </>
                      )}
                    </div>
                  </div>

                  {/* Selection Rounds Section - Expanded to fill space */}
                  {hasSelectionRounds && (
                    <div className="mt-6 p-4 bg-gray-50 rounded-lg min-h-[120px]">
                      <h4 className="font-medium text-gray-900 mb-4 text-lg">
                        Selection Rounds:
                      </h4>
                      <div className="space-y-3">
                        {drive.selectionRounds.map((round, index) => (
                          <div
                            key={index}
                            className="flex items-center justify-between p-3 bg-white rounded-lg border shadow-sm"
                          >
                            <div className="flex items-center gap-3">
                              <span className="px-3 py-2 bg-blue-100 text-blue-800 rounded-lg text-sm font-medium">
                                {round.name || `Round ${index + 1}`}
                              </span>
                              {round.selectedStudents &&
                                round.selectedStudents.length > 0 && (
                                  <span className="text-sm text-gray-600 font-medium">
                                    ({round.selectedStudents.length} selected)
                                  </span>
                                )}
                            </div>

                            {/* View selected students button for each round */}
                            {round.selectedStudents &&
                              round.selectedStudents.length > 0 && (
                                <button
                                  onClick={(e) => {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    console.log(
                                      "=== VIEW SELECTED CLICKED (PO) ==="
                                    );
                                    console.log("Drive:", drive.companyName);
                                    console.log(
                                      "Round:",
                                      round.name || `Round ${index + 1}`
                                    );
                                    console.log(
                                      "Selected Students:",
                                      round.selectedStudents
                                    );
                                    handleViewRoundStudents(
                                      drive,
                                      round,
                                      index
                                    );
                                  }}
                                  className="px-4 py-2 bg-green-100 text-green-700 hover:bg-green-200 rounded-lg text-sm font-medium"
                                >
                                  View Selected
                                </button>
                              )}
                          </div>
                        ))}
                      </div>
                    </div>
                  )}

                  {/* Footer with stats */}
                  <div className="mt-4 pt-4 border-t border-gray-200">
                    <div className="text-sm text-gray-500">
                      <p>Applications: {drive.applications?.length || 0}</p>
                      <p>
                        Placed Students: {getPlacedStudentsCount(drive)}
                        {drive.selectionRounds && drive.selectionRounds.length > 0 && isDriveEnded(drive) && (
                          <span className="text-xs italic text-gray-400 ml-2">
                            (from final round)
                          </span>
                        )}
                      </p>
                      <p>
                        Created by:{" "}
                        {drive.createdBy?.profile?.name ||
                          drive.createdBy?.email ||
                          (drive.createdBy
                            ? "Unknown User"
                            : "System Generated")}
                      </p>
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        )}
      </div>

      {/* Modal */}
      {showModal && <DriveModal drive={selectedDrive} onClose={closeModal} />}

      {/* Deletion Confirmation Modal */}
      {showDeleteModal && deleteTarget && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 w-full max-w-md mx-4">
            <div className="flex items-center mb-4">
              <div className="flex-shrink-0">
                <svg
                  className="h-6 w-6 text-red-600"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.464 0L4.35 18.5c-.77.833.192 2.5 1.732 2.5z"
                  />
                </svg>
              </div>
              <div className="ml-3">
                <h3 className="text-lg font-medium text-gray-900">
                  {user?.role === "po" || user?.role === "placement_officer"
                    ? "Delete Job Drive"
                    : "Request Job Drive Deletion"}
                </h3>
              </div>
            </div>

            <div className="mb-4">
              <p className="text-sm text-gray-600">
                {user?.role === "po" || user?.role === "placement_officer"
                  ? `Are you sure you want to delete "${deleteTarget.name}"? This action will be performed immediately and cannot be undone.`
                  : `Are you sure you want to request deletion of "${deleteTarget.name}"? This will require PO approval before the drive is deleted.`}
              </p>
            </div>

            {/* Reason input for PRs */}
            {(user?.role === "placement_representative" ||
              user?.role === "pr") && (
              <div className="mb-4">
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Reason for deletion *
                </label>
                <textarea
                  value={deleteReason}
                  onChange={(e) => setDeleteReason(e.target.value)}
                  className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent"
                  rows="3"
                  placeholder="Please provide a reason for requesting deletion..."
                  required
                />
              </div>
            )}

            <div className="flex justify-end space-x-3">
              <button
                onClick={cancelDelete}
                className="px-4 py-2 bg-gray-300 text-gray-700 rounded-md hover:bg-gray-400 transition-colors"
              >
                Cancel
              </button>
              <button
                onClick={confirmDeleteDrive}
                className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors"
              >
                {user?.role === "po" || user?.role === "placement_officer"
                  ? "Delete Drive"
                  : "Submit Request"}
              </button>
            </div>
          </div>
        </div>
      )}
      {/* Placed Students Modal */}
      {/* Removed Placed Students Modal */}

      {/* Student Deletion Confirmation Modal */}
      {showDeleteStudentModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 w-full max-w-md mx-4">
            <div className="flex items-center mb-4">
              <div className="flex-shrink-0">
                <svg
                  className="h-6 w-6 text-red-600"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.464 0L4.35 18.5c-.77.833.192 2.5 1.732 2.5z"
                  />
                </svg>
              </div>
              <div className="ml-3">
                <h3 className="text-lg font-medium text-gray-900">
                  Delete Student
                </h3>
              </div>
            </div>

            <div className="mb-4">
              <p className="text-sm text-gray-600">
                Are you sure you want to delete this student from the placed
                students list? This action cannot be undone.
              </p>
            </div>

            <div className="flex justify-end space-x-3">
              <button
                onClick={cancelDeleteStudent}
                className="px-4 py-2 bg-gray-300 text-gray-700 rounded-md hover:bg-gray-400 transition-colors"
              >
                Cancel
              </button>
              <button
                onClick={confirmDeleteStudent}
                className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors"
              >
                Delete Student
              </button>
            </div>
          </div>
        </div>
      )}
      {/* Placed Students View Modal for POs */}
      {showPlacedStudentsViewModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 w-full max-w-5xl max-h-[90vh] overflow-y-auto">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-bold">
                Placed Students - {selectedDriveForView?.companyName}
              </h2>
              <button
                onClick={() => {
                  setShowPlacedStudentsViewModal(false);
                  setSelectedDriveForView(null);
                }}
                className="text-gray-500 hover:text-gray-700 text-2xl"
              >
                ×
              </button>
            </div>

            {selectedDriveForView?.placedStudents && selectedDriveForView.placedStudents.length > 0 ? (
              <div>
                <div className="mb-4 p-4 bg-gray-50 rounded-lg">
                  <h3 className="font-semibold text-lg">Drive Summary</h3>
                  <p>
                    <span className="font-medium">Company:</span>{" "}
                    {selectedDriveForView.companyName}
                  </p>
                  <p>
                    <span className="font-medium">Role:</span>{" "}
                    {selectedDriveForView.role}
                  </p>
                  <p>
                    <span className="font-medium">Total Applications:</span>{" "}
                    {selectedDriveForView.applications?.length || 0}
                  </p>
                  <p>
                    <span className="font-medium">Total Placed:</span>{" "}
                    {selectedDriveForView.placedStudents?.length || 0}
                  </p>
                </div>

                <div className="overflow-x-auto">
                  <table className="min-w-full border border-gray-200">
                    <thead className="bg-gray-50">
                      <tr>
                        <th className="px-4 py-3 text-left text-sm font-medium text-gray-500 uppercase">
                          S.No
                        </th>
                        <th className="px-4 py-3 text-left text-sm font-medium text-gray-500 uppercase">
                          Name
                        </th>
                        <th className="px-4 py-3 text-left text-sm font-medium text-gray-500 uppercase">
                          Roll Number
                        </th>
                        <th className="px-4 py-3 text-left text-sm font-medium text-gray-500 uppercase">
                          Department
                        </th>
                        <th className="px-4 py-3 text-left text-sm font-medium text-gray-500 uppercase">
                          Email
                        </th>
                        <th className="px-4 py-3 text-left text-sm font-medium text-gray-500 uppercase">
                          Mobile
                        </th>
                        <th className="px-4 py-3 text-left text-sm font-medium text-gray-500 uppercase">
                          Added On
                        </th>
                      </tr>
                    </thead>
                    <tbody className="divide-y divide-gray-200">
                      {selectedDriveForView.placedStudents.map(
                        (student, index) => (
                          <tr key={index} className="hover:bg-gray-50">
                            <td className="px-4 py-3 text-sm">{index + 1}</td>
                            <td className="px-4 py-3 text-sm font-medium">
                              {student.name}
                            </td>
                            <td className="px-4 py-3 text-sm">
                              {student.rollNumber}
                            </td>
                            <td className="px-4 py-3 text-sm">
                              {student.department || "N/A"}
                            </td>
                            <td className="px-4 py-3 text-sm">
                              {student.email}
                            </td>
                            <td className="px-4 py-3 text-sm">
                              {student.mobileNumber || "N/A"}
                            </td>
                            <td className="px-4 py-3 text-sm">
                              {student.addedAt
                                ? new Date(student.addedAt).toLocaleDateString()
                                : "N/A"}
                            </td>
                          </tr>
                        )
                      )}
                    </tbody>
                  </table>
                </div>
              </div>
            ) : (
              <div className="text-center py-8">
                <p className="text-gray-500">
                  No placed students found for this drive.
                </p>
              </div>
            )}

            <div className="flex justify-between items-center mt-6">
              <button
                onClick={downloadCSV}
                className="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 flex items-center space-x-2"
              >
                <svg
                  className="w-4 h-4"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth="2"
                    d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                  />
                </svg>
                <span>Download CSV</span>
              </button>
              <button
                onClick={() => {
                  setShowPlacedStudentsViewModal(false);
                  setSelectedDriveForView(null);
                }}
                className="px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600"
              >
                Close
              </button>
            </div>
          </div>
        </div>
      )}
      {/* Round Management Modal */}
      <RoundManagementModal
        isOpen={showRoundModal}
        onClose={closeRoundModal}
        job={selectedJobForRounds}
        roundIndex={selectedRoundIndex}
      />
      {/* Round Students Modal for PO */}
      {showRoundStudentsModal && selectedRound && selectedJobForRoundView && (
        <RoundStudentsModal
          isOpen={showRoundStudentsModal}
          round={selectedRound}
          roundIndex={selectedRoundIndex}
          jobDrive={selectedJobForRoundView}
          onClose={closeRoundStudentsModal}
        />
      )}
      {/* Manage Rounds Modal */}
      {showManageRoundsModal && selectedDriveForRounds && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 w-full max-w-6xl max-h-[90vh] overflow-y-auto">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-bold">
                Manage Rounds - {selectedDriveForRounds.companyName}
              </h2>
              <button
                onClick={closeManageRoundsModal}
                className="text-gray-500 hover:text-gray-700 text-2xl"
              >
                ×
              </button>
            </div>

            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
              {/* Rounds List */}
              <div>
                <h3 className="text-lg font-semibold mb-3">Selection Rounds</h3>
                <div className="space-y-2">
                  {selectedDriveForRounds.selectionRounds?.map(
                    (round, index) => (
                      <div
                        key={index}
                        className={`p-3 border rounded-lg cursor-pointer transition-colors ${
                          selectedRoundIndex === index
                            ? "border-blue-500 bg-blue-50"
                            : "border-gray-200 hover:border-gray-300"
                        }`}
                        onClick={() => handleRoundSelect(round, index)}
                      >
                        <div className="flex justify-between items-center">
                          <span className="font-medium">
                            {round.name || `Round ${index + 1}`}
                          </span>
                          <span className="text-sm text-gray-600">
                            {round.selectedStudents?.length || 0} selected
                          </span>
                        </div>
                        {round.details && (
                          <p className="text-sm text-gray-600 mt-1">
                            {round.details}
                          </p>
                        )}
                      </div>
                    )
                  )}
                </div>
              </div>

              {/* Student Selection */}
              <div>
                {selectedRoundForManagement ? (
                  <div>
                    <div className="flex justify-between items-center mb-3">
                      <h3 className="text-lg font-semibold">
                        Select Students for{" "}
                        {selectedRoundForManagement.name ||
                          `Round ${selectedRoundIndex + 1}`}
                      </h3>
                      <span className="text-sm text-gray-600">
                        {selectedStudentsForRound.length} selected
                      </span>
                    </div>

                    {loadingApplicants ? (
                      <div className="text-center py-8">
                        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto"></div>
                        <p className="mt-2 text-gray-600">
                          Loading applicants...
                        </p>
                      </div>
                    ) : (
                      <div>
                        <div className="max-h-96 overflow-y-auto border rounded-lg">
                          {!roundApplicants || roundApplicants.length === 0 ? (
                            <div className="p-4 text-center text-gray-500">
                              No applicants found for this drive
                            </div>
                          ) : (
                            <div className="space-y-2 p-2">
                              {roundApplicants
                                .filter((student) => student && student._id)
                                .map((student) => (
                                  <div
                                    key={student._id}
                                    className={`p-3 border rounded cursor-pointer transition-colors ${
                                      selectedStudentsForRound.includes(
                                        student._id
                                      )
                                        ? "border-green-500 bg-green-50"
                                        : "border-gray-200 hover:border-gray-300"
                                    }`}
                                    onClick={() =>
                                      handleStudentSelection(student._id)
                                    }
                                  >
                                    <div className="flex justify-between items-center">
                                      <div>
                                        <p className="font-medium">
                                          {student.name || "N/A"}
                                        </p>
                                        <p className="text-sm text-gray-600">
                                          {student.email || "N/A"}
                                        </p>
                                        <p className="text-sm text-gray-600">
                                          {student.department || "N/A"}
                                        </p>
                                      </div>
                                      <div className="text-right">
                                        <p className="text-sm">
                                          CGPA: {student.cgpa || "N/A"}
                                        </p>
                                        <p className="text-sm">
                                          Roll Number:{" "}
                                          {student.rollNumber || "N/A"}
                                        </p>
                                      </div>
                                    </div>
                                  </div>
                                ))}
                            </div>
                          )}
                        </div>

                        <div className="flex justify-end space-x-3 mt-4">
                          <button
                            onClick={() => {
                              setSelectedRoundForManagement(null);
                              setSelectedRoundIndex(null);
                            }}
                            className="px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600"
                          >
                            Cancel
                          </button>
                          <button
                            onClick={handleSaveSelectedStudents}
                            className="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600"
                          >
                            Save Selection ({selectedStudentsForRound.length})
                          </button>
                        </div>
                      </div>
                    )}
                  </div>
                ) : (
                  <div className="text-center text-gray-500 py-8">
                    Select a round to manage students
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

const RoundStudentsModal = ({
  isOpen,
  onClose,
  round,
  roundIndex,
  jobDrive,
}) => {
  const [students, setStudents] = useState([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (
      isOpen &&
      round &&
      round.selectedStudents &&
      round.selectedStudents.length > 0
    ) {
      console.log("=== MODAL OPENED (PO) ===");
      console.log("Round:", round.name);
      console.log("Selected Students:", round.selectedStudents);
      fetchSelectedStudents();
    }
  }, [isOpen, round]);

  const fetchSelectedStudents = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem("token");

      console.log("=== FETCHING STUDENTS (PO) ===");
      console.log("Job Drive ID:", jobDrive._id);
      console.log("Student IDs to fetch:", round.selectedStudents);

      const response = await axios.post(
        `http://localhost:5000/api/job-drives/${jobDrive._id}/get-students-by-ids`,
        { studentIds: round.selectedStudents },
        {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
        }
      );

      console.log("✅ API Response received:", response.data);
      setStudents(response.data.students || []);
    } catch (error) {
      console.error("❌ Error fetching students:", error);
      console.error("Error response:", error.response?.data);
      toast.error("Failed to fetch selected students");
      setStudents([]);
    } finally {
      setLoading(false);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg p-6 w-full max-w-5xl max-h-[90vh] overflow-y-auto">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-bold">
            Selected Students - {round.name || `Round ${roundIndex + 1}`}
          </h2>
          <button
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700 text-2xl"
          >
            ×
          </button>
        </div>

        <div className="mb-4 p-3 bg-blue-50 rounded-lg">
          <p className="text-sm text-blue-700">
            <strong>Company:</strong> {jobDrive.companyName} |
            <strong> Round:</strong> {round.name || `Round ${roundIndex + 1}`} |
            <strong> Selected:</strong> {round.selectedStudents?.length || 0}{" "}
            students
          </p>
        </div>

        {loading ? (
          <div className="text-center py-8">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto"></div>
            <p className="mt-2 text-gray-600">Loading selected students...</p>
          </div>
        ) : students.length === 0 ? (
          <div className="text-center text-gray-500 py-8">
            <p>No student details found for this round.</p>
            <p className="text-sm mt-2">
              Selected Student IDs: {round.selectedStudents?.join(", ")}
            </p>
          </div>
        ) : (
          <div className="overflow-x-auto">
            <table className="min-w-full border border-gray-200">
              <thead className="bg-gray-50">
                <tr>
                  <th className="px-4 py-3 text-left text-sm font-medium text-gray-500 uppercase">
                    S.No
                  </th>
                  <th className="px-4 py-3 text-left text-sm font-medium text-gray-500 uppercase">
                    Name
                  </th>
                  <th className="px-4 py-3 text-left text-sm font-medium text-gray-500 uppercase">
                    Roll Number
                  </th>
                  <th className="px-4 py-3 text-left text-sm font-medium text-gray-500 uppercase">
                    Department
                  </th>
                  <th className="px-4 py-3 text-left text-sm font-medium text-gray-500 uppercase">
                    Email
                  </th>
                  <th className="px-4 py-3 text-left text-sm font-medium text-gray-500 uppercase">
                    Mobile
                  </th>
                  <th className="px-4 py-3 text-left text-sm font-medium text-gray-500 uppercase">
                    Added On
                  </th>
                </tr>
              </thead>
              <tbody className="divide-y divide-gray-200">
                {selectedDriveForView.placedStudents.map(
                  (student, index) => (
                    <tr key={index} className="hover:bg-gray-50">
                      <td className="px-4 py-3 text-sm">{index + 1}</td>
                      <td className="px-4 py-3 text-sm font-medium">
                        {student.name}
                      </td>
                      <td className="px-4 py-3 text-sm">
                        {student.rollNumber}
                      </td>
                      <td className="px-4 py-3 text-sm">
                        {student.department || "N/A"}
                      </td>
                      <td className="px-4 py-3 text-sm">
                        {student.email}
                      </td>
                      <td className="px-4 py-3 text-sm">
                        {student.mobileNumber || "N/A"}
                      </td>
                      <td className="px-4 py-3 text-sm">
                        {student.addedAt
                          ? new Date(student.addedAt).toLocaleDateString()
                          : "N/A"}
                      </td>
                    </tr>
                  )
                )}
              </tbody>
            </table>
          </div>
        )}

        <div className="mt-6 flex justify-end">
          <button
            onClick={onClose}
            className="px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600"
          >
            Close
          </button>
        </div>
      </div>
    </div>
  );
};

export default AllJobDrives;
